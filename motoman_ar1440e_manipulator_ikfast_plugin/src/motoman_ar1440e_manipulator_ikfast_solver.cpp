/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x10000049 generated on 2021-03-08 22:08:37.187422
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x10000049);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45,x46,x47,x48,x49,x50,x51,x52,x53,x54,x55,x56,x57,x58,x59;
x0=IKcos(j[0]);
x1=IKsin(j[0]);
x2=IKsin(j[2]);
x3=IKcos(j[1]);
x4=IKcos(j[2]);
x5=IKsin(j[1]);
x6=IKsin(j[3]);
x7=IKcos(j[3]);
x8=IKsin(j[4]);
x9=IKcos(j[4]);
x10=IKsin(j[6]);
x11=IKcos(j[5]);
x12=IKsin(j[5]);
x13=IKcos(j[6]);
x14=((0.094)*x8);
x15=((0.2)*x1);
x16=((1.0)*x4);
x17=((1.0)*x7);
x18=((1.0)*x8);
x19=((0.2)*x4);
x20=((0.64)*x4);
x21=((1.0)*x9);
x22=((0.62)*x5);
x23=((1.0)*x3);
x24=((0.094)*x9);
x25=(x2*x5);
x26=((-1.0)*x9);
x27=(x5*x7);
x28=(x0*x2);
x29=(x5*x6);
x30=((-1.0)*x8);
x31=(x3*x6);
x32=((-1.0)*x12);
x33=(x1*x2);
x34=((-1.0)*x11);
x35=(x1*x3);
x36=(x0*x3);
x37=(x0*x16);
x38=((1.0)*x1*x29);
x39=(x16*x27);
x40=((((-1.0)*x39))+x31);
x41=((((-1.0)*x16*x36))+(((1.0)*x33)));
x42=(x37+(((-1.0)*x23*x33)));
x43=((((-1.0)*x1*x16))+(((-1.0)*x23*x28)));
x44=((((-1.0)*x28))+(((-1.0)*x16*x35)));
x45=((((-1.0)*x17*x3))+(((-1.0)*x16*x29)));
x46=(x41*x7);
x47=(x44*x7);
x48=(x45*x9);
x49=(((x0*x27))+((x41*x6)));
x50=((((-1.0)*x0*x29))+x46);
x51=(((x1*x27))+((x44*x6)));
x52=((((-1.0)*x18*x25))+x48);
x53=(x49*x9);
x54=(x53+((x43*x8)));
x55=((((-1.0)*x18*x49))+((x21*(((((-1.0)*x1*x4))+(((-1.0)*x28*x3)))))));
x56=(((x51*x9))+((x42*x8)));
x57=(((x30*x51))+((x26*(((((-1.0)*x37))+((x3*x33)))))));
x58=(x11*x54);
x59=(x11*x56);
eerot[0]=(((x13*((((x12*x50))+x58))))+((x10*x55)));
eerot[1]=(((x13*x55))+((x10*((((x34*x54))+((x32*x50)))))));
eerot[2]=(((x12*x54))+((x11*(((((-1.0)*x17*x41))+(((1.0)*x0*x29)))))));
IkReal x60=(x0*x29);
eetrans[0]=(((x12*((((x14*x43))+((x24*x49))))))+((x6*((((x19*x36))+(((-1.0)*x15*x2))))))+(((-1.0)*x0*x22))+(((0.15)*x0))+(((-0.2)*x0*x27))+((x7*((((x20*x36))+(((-0.64)*x33))))))+(((0.64)*x60))+((x11*(((((0.094)*x60))+(((-0.094)*x46)))))));
eerot[3]=(((x10*x57))+((x13*((((x12*(((((-1.0)*x38))+x47))))+x59)))));
eerot[4]=(((x13*x57))+(((-1.0)*x10*(((((1.0)*x59))+(((1.0)*x12*(((((-1.0)*x1*x29))+x47)))))))));
eerot[5]=(((x12*x56))+((x11*(((((-1.0)*x47))+x38)))));
IkReal x61=(x1*x29);
eetrans[1]=(((x12*((((x24*x51))+((x14*x42))))))+(((-1.0)*x15*x27))+((x6*(((((0.2)*x28))+((x15*x3*x4))))))+((x7*((((x20*x35))+(((0.64)*x28))))))+(((-1.0)*x1*x22))+((x11*(((((0.094)*x61))+(((-0.094)*x47))))))+(((0.15)*x1))+(((0.64)*x61)));
eerot[6]=(((x13*((((x11*x52))+((x12*x40))))))+((x10*((((x30*x45))+((x25*x26)))))));
eerot[7]=(((x13*(((((-1.0)*x21*x25))+(((-1.0)*x18*x45))))))+((x10*((((x34*((x48+((x25*x30))))))+((x32*x40)))))));
eerot[8]=(((x12*x52))+((x11*((x39+(((-1.0)*x23*x6)))))));
eetrans[2]=((0.45)+(((0.62)*x3))+((x19*x29))+((x12*(((((-1.0)*x14*x25))+((x24*x45))))))+((x20*x27))+((x11*(((((-0.094)*x31))+(((0.094)*x27*x4))))))+(((-0.64)*x31))+(((0.2)*x3*x7)));
}

IKFAST_API int GetNumFreeParameters() { return 1; }
IKFAST_API int* GetFreeParameters() { static int freeparams[] = {2}; return freeparams; }
IKFAST_API int GetNumJoints() { return 7; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x67000001; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,j5,cj5,sj5,htj5,j5mul,j6,cj6,sj6,htj6,j6mul,j2,cj2,sj2,htj2,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_r10,r10,rxp1_0,new_r11,r11,rxp1_1,new_r12,r12,rxp1_2,new_r20,r20,rxp2_0,new_r21,r21,rxp2_1,new_r22,r22,rxp2_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij3[2], _nj3,_ij4[2], _nj4,_ij5[2], _nj5,_ij6[2], _nj6,_ij2[2], _nj2;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; j5=numeric_limits<IkReal>::quiet_NaN(); _ij5[0] = -1; _ij5[1] = -1; _nj5 = -1; j6=numeric_limits<IkReal>::quiet_NaN(); _ij6[0] = -1; _ij6[1] = -1; _nj6 = -1;  _ij2[0] = -1; _ij2[1] = -1; _nj2 = 0; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
j2=pfree[0]; cj2=cos(pfree[0]); sj2=sin(pfree[0]), htj2=tan(pfree[0]*0.5);
r00 = eerot[0*3+0];
r01 = eerot[0*3+1];
r02 = eerot[0*3+2];
r10 = eerot[1*3+0];
r11 = eerot[1*3+1];
r12 = eerot[1*3+2];
r20 = eerot[2*3+0];
r21 = eerot[2*3+1];
r22 = eerot[2*3+2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

new_r00=((-1.0)*r01);
new_r01=r00;
new_r02=r02;
new_px=((((-0.094)*r02))+px);
new_r10=((-1.0)*r11);
new_r11=r10;
new_r12=r12;
new_py=(py+(((-0.094)*r12)));
new_r20=((-1.0)*r21);
new_r21=r20;
new_r22=r22;
new_pz=((-0.45)+pz+(((-0.094)*r22)));
r00 = new_r00; r01 = new_r01; r02 = new_r02; r10 = new_r10; r11 = new_r11; r12 = new_r12; r20 = new_r20; r21 = new_r21; r22 = new_r22; px = new_px; py = new_py; pz = new_pz;
IkReal x62=((1.0)*px);
IkReal x63=((1.0)*pz);
IkReal x64=((1.0)*py);
pp=((px*px)+(py*py)+(pz*pz));
npx=(((px*r00))+((py*r10))+((pz*r20)));
npy=(((px*r01))+((py*r11))+((pz*r21)));
npz=(((px*r02))+((py*r12))+((pz*r22)));
rxp0_0=((((-1.0)*r20*x64))+((pz*r10)));
rxp0_1=(((px*r20))+(((-1.0)*r00*x63)));
rxp0_2=((((-1.0)*r10*x62))+((py*r00)));
rxp1_0=((((-1.0)*r21*x64))+((pz*r11)));
rxp1_1=(((px*r21))+(((-1.0)*r01*x63)));
rxp1_2=((((-1.0)*r11*x62))+((py*r01)));
rxp2_0=(((pz*r12))+(((-1.0)*r22*x64)));
rxp2_1=(((px*r22))+(((-1.0)*r02*x63)));
rxp2_2=((((-1.0)*r12*x62))+((py*r02)));
IkReal op[8+1], zeror[8];
int numroots;
IkReal x65=((0.3)*px);
IkReal x66=((1.0)*pp);
IkReal x67=((0.64)*sj2);
IkReal x68=((1.0)*py);
IkReal x69=(x67+(((-1.0)*x68)));
IkReal x70=((1.0595)+x65+(((-1.0)*x66)));
IkReal x71=((0.5635)+x65+(((-1.0)*x66)));
IkReal x72=(x65+x66);
IkReal x73=((((-1.0)*x68))+(((-1.0)*x67)));
IkReal x74=((1.0595)+(((-1.0)*x72)));
IkReal x75=((0.5635)+(((-1.0)*x72)));
IkReal gconst0=x70;
IkReal gconst1=x71;
IkReal gconst2=x70;
IkReal gconst3=x71;
IkReal gconst4=x73;
IkReal gconst5=x69;
IkReal gconst6=x74;
IkReal gconst7=x75;
IkReal gconst8=x73;
IkReal gconst9=x69;
IkReal gconst10=x74;
IkReal gconst11=x75;
IkReal x76=sj2*sj2;
IkReal x77=px*px;
IkReal x78=py*py;
IkReal x79=(gconst4*py);
IkReal x80=((0.384)*sj2);
IkReal x81=((0.6)*gconst9);
IkReal x82=(gconst11*sj2);
IkReal x83=((1.0)*gconst6);
IkReal x84=(gconst1*gconst9);
IkReal x85=(gconst10*gconst4);
IkReal x86=((0.64)*gconst6);
IkReal x87=((0.64)*gconst4);
IkReal x88=((0.6)*gconst4);
IkReal x89=(gconst6*py);
IkReal x90=(gconst7*sj2);
IkReal x91=((0.63488)*py);
IkReal x92=(gconst2*px);
IkReal x93=(gconst2*gconst5);
IkReal x94=(gconst1*py);
IkReal x95=((1.0)*gconst0);
IkReal x96=(gconst3*px);
IkReal x97=(gconst3*py);
IkReal x98=((0.63488)*sj2);
IkReal x99=(gconst1*gconst8);
IkReal x100=((1.26976)*sj2);
IkReal x101=((2.0)*gconst9);
IkReal x102=(gconst10*px);
IkReal x103=(gconst5*gconst8);
IkReal x104=(gconst3*sj2);
IkReal x105=(gconst0*gconst5);
IkReal x106=(gconst5*py);
IkReal x107=((0.380928)*sj2);
IkReal x108=(gconst7*py);
IkReal x109=(px*py);
IkReal x110=(gconst1*gconst2);
IkReal x111=(gconst0*gconst8);
IkReal x112=(gconst0*py);
IkReal x113=(gconst1*sj2);
IkReal x114=(gconst10*gconst7);
IkReal x115=(gconst11*gconst5);
IkReal x116=((1.2)*px);
IkReal x117=((1.0)*gconst7);
IkReal x118=(gconst10*sj2);
IkReal x119=(gconst2*gconst7);
IkReal x120=(gconst4*gconst9);
IkReal x121=(gconst11*gconst8);
IkReal x122=(gconst4*gconst8);
IkReal x123=(gconst0*sj2);
IkReal x124=((2.0)*gconst4);
IkReal x125=(gconst11*gconst6);
IkReal x126=((1.536)*sj2);
IkReal x127=(gconst2*py);
IkReal x128=(gconst10*gconst9);
IkReal x129=(gconst11*py);
IkReal x130=((1.523712)*sj2);
IkReal x131=((2.0)*px);
IkReal x132=(gconst11*px);
IkReal x133=((5.03840768)*px);
IkReal x134=(gconst6*sj2);
IkReal x135=((0.6)*gconst5);
IkReal x136=((0.768)*sj2);
IkReal x137=(gconst8*py);
IkReal x138=((1.6122904576)*sj2);
IkReal x139=(gconst3*gconst6);
IkReal x140=((0.6)*gconst8);
IkReal x141=((1.0)*gconst11);
IkReal x142=(gconst1*gconst3);
IkReal x143=(gconst2*sj2);
IkReal x144=(gconst1*px);
IkReal x145=(gconst5*x133);
IkReal x146=(gconst8*x133);
IkReal x147=(gconst5*x138);
IkReal x148=((2.51920384)*x106);
IkReal x149=((10.07681536)*x77);
IkReal x150=((2.51920384)*x137);
IkReal x151=(gconst8*x138);
IkReal x152=((0.768)*x78);
IkReal x153=(gconst2*x78);
IkReal x154=((0.8126464)*x76);
IkReal x155=(gconst5*x118);
IkReal x156=((0.49152)*x76);
IkReal x157=(gconst0*x78);
IkReal x158=(gconst3*x78);
IkReal x159=((0.58752)*x76);
IkReal x160=(gconst10*x78);
IkReal x161=(gconst10*x76);
IkReal x162=((0.5696)*x76);
IkReal x163=((4.0)*x77);
IkReal x164=((0.4063232)*x76);
IkReal x165=((0.36)*x78);
IkReal x166=(gconst1*x78);
IkReal x167=((0.4096)*x76);
IkReal x168=((1.28)*x143);
IkReal x169=((0.192)*x76);
IkReal x170=(x106*x107);
IkReal x171=(x107*x137);
IkReal x172=((1.26976)*px*x90);
IkReal x173=(x100*x102);
IkReal x174=(x118*x91);
IkReal x175=((0.4063232)*x161);
IkReal x176=(x93*x98);
IkReal x177=(x90*x91);
IkReal x178=(x98*x99);
IkReal x179=(x109*x130);
IkReal x180=(gconst7*x164);
IkReal x181=((4.0)*gconst0*x109);
IkReal x182=(gconst0*x167);
IkReal x183=(x76*x78);
IkReal x184=(x173+x172);
IkReal x185=(x171+x170+x145+x146);
IkReal x186=(x179+x151+x150+x148+x149+x180);
IkReal x187=(x178+x175+x174+x177+x176+x147);
op[0]=((((-0.16)*x114*x76))+(((-1.0)*gconst4*x117*x121))+((gconst10*gconst5*x98))+((x103*x125))+(((-2.51920384)*x103))+((gconst7*gconst9*x85))+(((-1.0)*gconst5*x128*x83))+(((0.63488)*gconst8*x90)));
op[1]=((((-1.0)*gconst6*x121*x131))+(((-1.0)*gconst7*x131*x85))+((gconst6*x101*x102))+((gconst7*x124*x132))+(((-1.0)*gconst7*x140*x79))+(((-1.0)*gconst5*x81*x89))+(((-1.0)*gconst7*x101*x102))+(((-1.0)*gconst6*x115*x131))+(((2.0)*gconst5*gconst6*x102))+(((-1.0)*x184))+(((-0.096)*py*x161))+(((-0.096)*x108*x76))+((gconst7*x121*x131))+(((0.6)*x103*x129))+x185+((gconst10*x79*x81))+((gconst7*x79*x81))+(((-1.0)*gconst10*x106*x81))+(((-0.6)*x121*x79))+(((0.6)*x103*x89)));
op[2]=((((-0.64)*x128*x90))+((x84*x85))+((x114*x163))+((x103*x165))+(((-1.0)*gconst10*gconst6*x163))+(((1.2)*x102*x106))+(((-1.0)*x122*x165))+((x120*x165))+((gconst9*x116*x89))+((x103*x139))+(((-1.0)*x186))+(((-1.0)*gconst8*x116*x89))+(((-1.0)*gconst11*x117*x79))+(((-0.32)*x114*x76))+(((-1.0)*x108*x121))+((x108*x128))+((gconst11*x116*x79))+(((-1.0)*gconst3*x117*x122))+(((-0.16)*gconst1*x161))+x187+(((1.26976)*gconst8*x90))+(((-1.0)*gconst11*gconst7*x163))+(((-1.0)*gconst5*x82*x86))+((x121*x89))+((gconst0*gconst11*x103))+((gconst8*x82*x86))+((gconst8*x108*x116))+(((-1.0)*gconst10*x106*x83))+(((-1.0)*x155*x86))+(((-1.0)*gconst5*x128*x95))+(((-1.0)*gconst5*gconst9*x165))+(((-1.0)*py*x128*x83))+(((-1.2)*x102*x79))+(((-1.0)*gconst9*x118*x86))+(((-5.03840768)*x103))+(((-1.0)*gconst9*x108*x116))+((x125*x163))+((gconst7*x82*x87))+((x115*x89))+(((-1.0)*gconst9*x83*x93))+((gconst10*gconst5*x100))+((x119*x120))+(((-0.16)*x119*x76))+(((-0.0576)*x183))+(((-1.0)*gconst11*x106*x116))+(((0.64)*x85*x90))+(((0.64)*gconst7*gconst8*x82))+(((-1.0)*gconst4*x141*x99))+((x114*x79)));
op[3]=((((-2.0)*gconst1*gconst10*gconst4*px))+(((-0.384)*gconst11*gconst5*py*sj2))+(((2.0)*gconst3*gconst7*gconst8*px))+(((-2.0)*gconst0*gconst11*gconst5*px))+(((-4.0)*gconst11*gconst6*px*py))+(((0.768)*gconst11*gconst8*py*sj2))+(((2.0)*gconst0*gconst10*gconst9*px))+(((0.384)*gconst11*gconst4*py*sj2))+(((2.56)*gconst10*gconst6*px*sj2))+(((2.0)*gconst2*gconst6*gconst9*px))+(((0.6)*gconst3*gconst5*gconst8*py))+(((0.768)*gconst4*gconst7*py*sj2))+(((-0.096)*gconst1*py*(sj2*sj2)))+(((-0.6)*gconst10*gconst5*(py*py)))+(((-0.6)*gconst3*gconst4*gconst8*py))+(((-2.0)*gconst2*gconst4*gconst7*px))+(((0.6)*gconst6*gconst8*(py*py)))+(((0.761856)*sj2*(py*py)))+(((-0.384)*gconst6*gconst9*py*sj2))+(((0.384)*gconst7*gconst8*py*sj2))+(((-0.192)*gconst7*py*(sj2*sj2)))+(((10.07681536)*gconst8*px))+(((-0.768)*gconst10*gconst9*py*sj2))+(((0.6)*gconst2*gconst4*gconst9*py))+(((-0.384)*gconst10*gconst5*py*sj2))+(((0.761856)*gconst8*py*sj2))+(((4.0)*gconst10*gconst6*px*py))+(((-2.0)*gconst2*gconst7*gconst9*px))+(((-0.096)*gconst2*py*(sj2*sj2)))+(((-0.6)*gconst0*gconst5*gconst9*py))+(((0.6)*gconst10*gconst4*(py*py)))+(((0.6)*gconst1*gconst4*gconst9*py))+(((2.0)*gconst1*gconst11*gconst8*px))+(((-2.53952)*gconst10*px*sj2))+(((2.0)*gconst3*gconst4*gconst7*px))+(((-4.0)*gconst10*gconst7*px*py))+(((0.6)*gconst7*gconst9*(py*py)))+(((0.6)*gconst11*gconst5*(py*py)))+(((-1.26976)*gconst2*px*sj2))+(((10.07681536)*px*py))+(((-0.6)*gconst7*gconst8*(py*py)))+(((-0.768)*gconst5*gconst6*py*sj2))+(((-2.53952)*gconst7*px*sj2))+(((-1.26976)*gconst1*px*sj2))+(((-0.6)*gconst1*gconst4*gconst8*py))+(((2.0)*gconst2*gconst5*gconst6*px))+(((-0.384)*gconst7*gconst9*py*sj2))+(((0.384)*gconst10*gconst4*py*sj2))+(((0.384)*gconst6*gconst8*py*sj2))+(((-2.56)*gconst11*gconst7*px*sj2))+(((-0.6)*gconst11*gconst4*(py*py)))+(((0.6)*gconst0*gconst5*gconst8*py))+(((2.0)*gconst0*gconst10*gconst5*px))+(((4.0)*gconst11*gconst7*px*py))+(((-2.0)*gconst3*gconst5*gconst6*px))+(((-0.6)*gconst2*gconst5*gconst9*py))+(((-0.192)*gconst10*py*(sj2*sj2)))+(((-2.0)*gconst1*gconst10*gconst9*px))+(((-0.6)*gconst6*gconst9*(py*py)))+(((0.761856)*gconst5*py*sj2))+(((2.0)*gconst1*gconst11*gconst4*px))+(((10.07681536)*gconst5*px))+(((-2.0)*gconst3*gconst6*gconst8*px))+(((-2.0)*gconst0*gconst11*gconst8*px)));
op[4]=((((-0.4608)*gconst5*sj2*(py*py)))+(((-0.64)*gconst0*gconst10*gconst9*sj2))+((gconst1*gconst2*gconst4*gconst9))+(((0.64)*gconst3*gconst4*gconst7*sj2))+(((-4.0)*gconst3*gconst7*(px*px)))+(((0.63488)*gconst7*gconst8*sj2))+(((-0.64)*gconst2*gconst6*gconst9*sj2))+(((-0.64)*gconst1*gconst10*gconst9*sj2))+(((0.64)*gconst1*gconst10*gconst4*sj2))+(((0.64)*gconst3*gconst7*gconst8*sj2))+(((0.63488)*gconst1*py*sj2))+(((-4.0)*gconst0*gconst10*(px*px)))+(((0.63488)*gconst10*gconst5*sj2))+(((1.2)*gconst2*gconst5*px*py))+(((-1.28)*gconst10*gconst6*py*sj2))+(((1.26976)*gconst7*py*sj2))+(((-0.32)*gconst1*gconst10*(sj2*sj2)))+(((1.2)*gconst3*gconst4*px*py))+(((-1.0)*gconst10*gconst6*(py*py)))+(((-0.64)*gconst2*gconst7*gconst9*sj2))+(((1.2)*gconst0*gconst9*px*py))+((gconst0*gconst3*gconst5*gconst8))+(((-1.2)*gconst1*gconst9*px*py))+((gconst2*gconst7*gconst9*py))+(((-0.4096)*gconst11*gconst7*(sj2*sj2)))+((gconst1*gconst10*gconst9*py))+(((4.0)*gconst2*gconst7*(px*px)))+(((-1.0)*gconst1*gconst3*gconst4*gconst8))+((gconst3*gconst6*gconst8*py))+(((-1.0)*gconst1*gconst11*gconst8*py))+((gconst10*gconst7*(py*py)))+(((0.64)*gconst2*gconst4*gconst7*sj2))+(((3.2245809152)*gconst5*sj2))+(((-3.2245809152)*gconst8*sj2))+(((-0.32)*gconst2*gconst7*(sj2*sj2)))+(((-5.03840768)*gconst8*py))+(((0.64)*gconst1*gconst11*gconst4*sj2))+(((-0.4608)*gconst9*sj2*(py*py)))+(((-1.0)*gconst2*gconst6*gconst9*py))+(((4.0)*gconst3*gconst6*(px*px)))+(((-1.536)*gconst11*px*py*sj2))+(((0.63488)*gconst2*py*sj2))+(((-1.0)*gconst1*gconst11*gconst4*py))+(((-0.64)*gconst0*gconst11*gconst5*sj2))+(((-0.4096)*gconst10*gconst6*(sj2*sj2)))+(((-0.8126464)*gconst7*(sj2*sj2)))+(((-1.0)*gconst11*gconst7*(py*py)))+(((-0.16)*gconst1*gconst2*(sj2*sj2)))+(((-0.64)*gconst2*gconst5*gconst6*sj2))+(((-4.0)*gconst1*gconst11*(px*px)))+(((1.26976)*gconst1*gconst8*sj2))+(((1.536)*gconst10*px*py*sj2))+(((1.26976)*gconst2*gconst5*sj2))+(((0.4608)*gconst8*sj2*(py*py)))+(((-5.03840768)*gconst5*py))+(((0.64)*gconst3*gconst6*gconst8*sj2))+(((0.4608)*gconst4*sj2*(py*py)))+(((0.64)*gconst0*gconst11*gconst8*sj2))+(((-3.047424)*px*py*sj2))+(((0.4063232)*gconst2*(sj2*sj2)))+(((-0.4096)*gconst11*gconst6*(sj2*sj2)))+((gconst1*gconst10*gconst4*py))+(((-2.51920384)*(py*py)))+(((-1.0)*gconst0*gconst10*gconst5*py))+(((-1.0)*gconst0*gconst2*gconst5*gconst9))+(((-1.2)*gconst3*gconst5*px*py))+((gconst0*gconst11*gconst5*py))+(((-0.64)*gconst3*gconst5*gconst6*sj2))+((gconst0*gconst11*gconst8*py))+(((-1.0)*gconst0*gconst10*gconst9*py))+(((1.2)*gconst1*gconst8*px*py))+(((1.26976)*gconst10*py*sj2))+(((-1.536)*gconst7*px*py*sj2))+((gconst3*gconst5*gconst6*py))+(((0.8126464)*gconst10*(sj2*sj2)))+(((-0.4063232)*gconst1*(sj2*sj2)))+(((-1.0)*gconst3*gconst7*gconst8*py))+(((4.0)*gconst1*gconst10*(px*px)))+(((-20.15363072)*(px*px)))+(((1.536)*gconst6*px*py*sj2))+(((-1.2)*gconst0*gconst8*px*py))+(((-0.64)*gconst0*gconst10*gconst5*sj2))+(((-0.1152)*(py*py)*(sj2*sj2)))+(((1.031865892864)*(sj2*sj2)))+((gconst2*gconst4*gconst7*py))+(((-2.51920384)*gconst5*gconst8))+(((-0.5696)*gconst10*gconst7*(sj2*sj2)))+((gconst11*gconst6*(py*py)))+(((-1.2)*gconst2*gconst4*px*py))+(((-4.0)*gconst2*gconst6*(px*px)))+(((0.64)*gconst1*gconst11*gconst8*sj2))+(((4.0)*gconst0*gconst11*(px*px)))+(((1.28)*gconst11*gconst7*py*sj2))+(((-1.0)*gconst2*gconst5*gconst6*py))+(((-1.0)*gconst3*gconst4*gconst7*py)));
op[5]=(((x152*x90))+(((0.6)*x111*x78))+((gconst1*x124*x96))+(((4.0)*x108*x96))+(((-1.0)*x134*x152))+((gconst8*x136*x97))+(((-1.0)*gconst9*x127*x136))+(((-1.0)*x158*x88))+(((4.0)*x102*x112))+(((-2.56)*x144*x82))+(((-2.0)*x84*x92))+(((2.0)*x105*x92))+(((-1.0)*x127*x169))+(((-1.0)*x157*x81))+(((2.56)*x102*x123))+(((-2.56)*x90*x96))+(((2.0)*x96*x99))+(((-1.0)*gconst1*x124*x92))+(((-1.0)*x184))+((x153*x88))+(((-1.0)*py*x80*x93))+((gconst2*x79*x80))+(((-1.0)*x129*x156))+((gconst0*x101*x92))+((x135*x158))+(((-1.0)*py*x80*x84))+(((4.0)*x132*x94))+x185+((x166*x81))+(((-4.0)*x102*x94))+((x130*x78))+(((-1.0)*py*x105*x136))+(((4.0)*x89*x92))+(((-1.0)*x169*x94))+((gconst3*x79*x80))+(((-2.0)*x111*x96))+(((-1.0)*x156*x89))+(((-1.0)*gconst5*x80*x97))+(((-1.0)*gconst9*x112*x80))+(((-2.53952)*px*x113))+(((-2.53952)*sj2*x92))+(((-1.0)*gconst10*py*x159))+(((20.15363072)*x109))+(((-1.0)*x108*x159))+(((-1.0)*x118*x152))+((gconst8*x80*x94))+(((0.768)*x113*x79))+(((-1.0)*gconst11*x181))+(((-4.0)*x89*x96))+(((-4.0)*x108*x92))+(((2.56)*x134*x92))+(((-2.0)*x105*x96))+((x152*x82))+((py*x111*x80))+(((-0.6)*x78*x99))+(((-0.6)*x78*x93)));
op[6]=((((-1.0)*x160*x95))+(((-0.32)*x110*x76))+(((-1.0)*x142*x163))+(((-1.0)*gconst0*gconst2*x163))+((x110*x79))+(((0.64)*x104*x111))+((x100*x94))+(((2.063731785728)*x76))+(((-1.28)*x112*x118))+((x110*x163))+(((-5.03840768)*x78))+(((-1.0)*x153*x83))+(((-1.0)*gconst3*gconst7*x167))+(((-0.64)*x104*x105))+(((-1.0)*x186))+(((-0.64)*gconst2*gconst9*x123))+((gconst11*x157))+x187+(((-0.4096)*gconst0*x161))+((py*x126*x92))+((sj2*x110*x87))+((gconst0*gconst3*x163))+((gconst1*x104*x87))+(((-1.0)*x117*x158))+(((-1.0)*x141*x166))+((x119*x78))+((x139*x78))+(((-1.0)*x139*x167))+(((-0.64)*x143*x84))+((x111*x97))+(((-1.0)*x142*x79))+(((-1.0)*gconst1*x154))+((x127*x84))+(((-0.647424)*x183))+(((-1.0)*x119*x162))+((gconst1*x160))+((gconst2*x154))+(((-1.0)*py*x93*x95))+(((1.28)*x90*x97))+(((-0.64)*x123*x93))+(((-0.5696)*gconst1*x161))+((x100*x127))+(((1.28)*x82*x94))+((x105*x97))+(((-1.0)*py*x126*x96))+(((-1.0)*gconst11*x182))+(((-1.0)*gconst9*x127*x95))+(((1.536)*x109*x123))+(((-1.0)*gconst1*gconst11*x167))+(((-1.0)*gconst2*gconst6*x167))+(((0.64)*x104*x99))+(((-1.0)*x168*x89))+(((-1.0)*px*x126*x94))+(((-1.0)*gconst3*gconst8*x94)));
op[7]=((((-1.0)*x136*x153))+(((-2.56)*x113*x96))+(((-1.0)*x127*x159))+((x113*x152))+(((4.0)*x112*x92))+(((-1.0)*x159*x94))+(((10.07681536)*x109))+(((-1.0)*x123*x152))+(((-4.0)*x112*x96))+(((-4.0)*x92*x94))+(((4.0)*x94*x96))+((x104*x152))+(((2.56)*x123*x92))+(((-1.0)*x156*x97))+(((0.761856)*sj2*x78))+(((-1.0)*x112*x156))+(((-1.0)*x100*x92))+(((-1.0)*x100*x144)));
op[8]=(((x113*x91))+(((-1.0)*gconst3*x182))+(((-1.0)*x142*x167))+((x110*x78))+((gconst3*x157))+(((-1.0)*x153*x95))+(((-1.0)*x110*x162))+(((-2.51920384)*x78))+(((-1.0)*gconst1*x164))+(((-1.0)*x142*x78))+(((1.031865892864)*x76))+((x143*x91))+((gconst2*x164))+(((-1.0)*gconst2*x182))+(((1.28)*x104*x94))+(((-1.0)*x112*x168)));
polyroots8(op,zeror,numroots);
IkReal j0array[8], cj0array[8], sj0array[8], tempj0array[1];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ++ij0)
{
IkReal htj0 = zeror[ij0];
tempj0array[0]=((2.0)*(atan(htj0)));
for(int kj0 = 0; kj0 < 1; ++kj0)
{
j0array[numsolutions] = tempj0array[kj0];
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
numsolutions++;
}
}
bool j0valid[8]={true,true,true,true,true,true,true,true};
_nj0 = 8;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];
htj0 = IKtan(j0/2);

_ij0[0] = ij0; _ij0[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( j0valid[iij0] && IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH )
{
    j0valid[iij0]=false; _ij0[1] = iij0; break; 
}
}
{
IkReal j3eval[3];
IkReal x188=(pp*sj2);
IkReal x189=(px*sj0);
IkReal x190=(cj0*py);
IkReal x191=(cj0*px*sj2);
IkReal x192=(py*sj0*sj2);
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
j3eval[2]=((IKabs(((((12400.0)*x190))+(((3125.0)*x188))+(((-937.5)*x192))+(((-937.5)*x191))+(((-2535.9375)*sj2))+(((-12400.0)*x189)))))+(IKabs(((((8115.0)*sj2))+(((3000.0)*x192))+(((3000.0)*x191))+(((-3875.0)*x189))+(((3875.0)*x190))+(((-10000.0)*x188))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x193=py*py;
IkReal x194=cj0*cj0;
IkReal x195=pz*pz;
IkReal x196=px*px;
IkReal x197=((44.4444444444444)*sj2);
IkReal x198=((9.3)*sj2);
IkReal x199=(cj0*px);
IkReal x200=(py*sj0);
IkReal x201=((13.3333333333333)*sj2);
IkReal x202=((31.0)*sj2);
IkReal x203=(x193*x194);
IkReal x204=(x194*x196);
j1eval[0]=((((-1.0)*sj2))+(((-1.0)*x195*x197))+((x200*x201))+(((-1.0)*x197*x204))+((x197*x203))+(((-1.0)*x193*x197))+((x199*x201))+(((-88.8888888888889)*sj2*x199*x200)));
j1eval[1]=IKsign(((((-1.0)*x195*x202))+((x198*x200))+((x198*x199))+(((-0.6975)*sj2))+(((-62.0)*sj2*x199*x200))+(((-1.0)*x202*x204))+((x202*x203))+(((-1.0)*x193*x202))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
if( (((0.976008697297665)+(((0.360816523954774)*cj0*px))+(((-1.20272174651591)*pp))+(((0.360816523954774)*py*sj0)))) < -1-IKFAST_SINCOS_THRESH || (((0.976008697297665)+(((0.360816523954774)*cj0*px))+(((-1.20272174651591)*pp))+(((0.360816523954774)*py*sj0)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x205=IKasin(((0.976008697297665)+(((0.360816523954774)*cj0*px))+(((-1.20272174651591)*pp))+(((0.360816523954774)*py*sj0))));
j3array[0]=((-2.83870778521482)+(((-1.0)*x205)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((0.302884868374971)+x205);
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j1eval[2];
sj2=0;
cj2=1.0;
j2=0;
IkReal x206=(pz*sj3);
IkReal x207=((0.64)*cj3);
IkReal x208=(cj0*px);
IkReal x209=(py*sj0);
IkReal x210=((0.2)*sj3);
IkReal x211=((21.3333333333333)*cj3);
IkReal x212=((6.66666666666667)*sj3);
IkReal x213=(cj3*pz);
j1eval[0]=(sj3+(((-21.3333333333333)*x206))+(((6.66666666666667)*x213))+(((3.2)*cj3))+(((-1.0)*x208*x211))+(((-1.0)*x208*x212))+(((20.6666666666667)*pz))+(((-1.0)*x209*x212))+(((-1.0)*x209*x211)));
j1eval[1]=IKsign(((((-0.64)*x206))+(((0.03)*sj3))+(((0.2)*x213))+(((-1.0)*x207*x209))+(((-1.0)*x207*x208))+(((0.62)*pz))+(((0.096)*cj3))+(((-1.0)*x208*x210))+(((-1.0)*x209*x210))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=1.0;
j2=0;
IkReal x214=cj3*cj3;
IkReal x215=(py*sj0);
IkReal x216=(cj0*px);
IkReal x217=(pz*sj3);
IkReal x218=((0.2)*cj3);
IkReal x219=(cj3*pz);
IkReal x220=((21.3333333333333)*sj3);
IkReal x221=(cj3*sj3);
IkReal x222=((0.64)*sj3);
IkReal x223=((6.66666666666667)*cj3);
j1eval[0]=((-3.1)+(((-1.0)*x216*x220))+(((-1.0)*x215*x220))+((x216*x223))+(((3.2)*sj3))+((x215*x223))+(((20.6666666666667)*x216))+(((20.6666666666667)*x215))+(((21.3333333333333)*x219))+(((6.66666666666667)*x217))+(((-1.0)*cj3)));
j1eval[1]=((IKabs(((-0.128)+(((0.256)*x214))+((pz*x216))+((pz*x215))+(((0.3968)*cj3))+(((-0.3696)*x221))+(((-0.15)*pz))+(((0.124)*sj3)))))+(IKabs(((-0.794)+(((-0.248)*cj3))+(((0.7936)*sj3))+(((0.256)*x221))+(pz*pz)+(((0.3696)*x214))))));
j1eval[2]=IKsign(((-0.093)+(((-1.0)*x216*x222))+(((-1.0)*x215*x222))+((x216*x218))+((x215*x218))+(((0.2)*x217))+(((0.096)*sj3))+(((0.64)*x219))+(((0.62)*x215))+(((0.62)*x216))+(((-0.03)*cj3))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=1.0;
j2=0;
IkReal x224=cj0*cj0;
IkReal x225=py*py;
IkReal x226=pz*pz;
IkReal x227=px*px;
IkReal x228=(cj0*px);
IkReal x229=(py*sj0);
IkReal x230=(x224*x225);
IkReal x231=(x224*x227);
j1eval[0]=((1.0)+(((-44.4444444444444)*x230))+(((88.8888888888889)*x228*x229))+(((-13.3333333333333)*x229))+(((-13.3333333333333)*x228))+(((44.4444444444444)*x231))+(((44.4444444444444)*x225))+(((44.4444444444444)*x226)));
j1eval[1]=IKsign(((0.0225)+(((-0.3)*x228))+(((-0.3)*x229))+x225+x226+x231+(((2.0)*x228*x229))+(((-1.0)*x230))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x232=cj0*cj0;
IkReal x233=py*py;
IkReal x234=(py*sj0);
IkReal x235=((0.2)*sj3);
IkReal x236=(cj0*px);
IkReal x237=(cj3*pz);
IkReal x238=((0.2)*cj3);
IkReal x239=((0.64)*cj3);
IkReal x240=((0.64)*sj3);
CheckValue<IkReal> x241=IKPowWithIntegerCheck(IKsign(((0.0225)+(((2.0)*x234*x236))+(((-1.0)*x232*x233))+x233+(pz*pz)+(((-0.3)*x236))+(((-0.3)*x234))+((x232*(px*px))))),-1);
if(!x241.valid){
continue;
}
CheckValue<IkReal> x242 = IKatan2WithCheck(IkReal(((0.093)+(((-0.096)*sj3))+((x234*x240))+((x236*x240))+(((0.03)*cj3))+((pz*x235))+(((0.64)*x237))+(((-1.0)*x236*x238))+(((-1.0)*x234*x238))+(((-0.62)*x234))+(((-0.62)*x236)))),IkReal(((((-0.03)*sj3))+((x234*x239))+((x234*x235))+(((0.2)*x237))+(((-1.0)*pz*x240))+(((-0.096)*cj3))+((x235*x236))+(((0.62)*pz))+((x236*x239)))),IKFAST_ATAN2_MAGTHRESH);
if(!x242.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x241.value)))+(x242.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x243=IKsin(j1);
IkReal x244=IKcos(j1);
IkReal x245=((0.2)*cj3);
IkReal x246=(cj0*px);
IkReal x247=((0.64)*sj3);
IkReal x248=((0.2)*sj3);
IkReal x249=((0.64)*cj3);
IkReal x250=(py*sj0);
IkReal x251=((1.0)*x243);
IkReal x252=((1.0)*x244);
IkReal x253=(pz*x244);
IkReal x254=((1.24)*x243);
evalcond[0]=((-0.62)+(((-1.0)*x250*x251))+(((0.15)*x243))+(((-1.0)*x246*x251))+x253+x247+(((-1.0)*x245)));
evalcond[1]=((((-1.0)*x250*x252))+(((0.15)*x244))+(((-1.0)*x246*x252))+x249+x248+(((-1.0)*pz*x251)));
evalcond[2]=(((x244*x245))+(((0.62)*x244))+(((-1.0)*pz))+((x243*x248))+((x243*x249))+(((-1.0)*x244*x247)));
evalcond[3]=((0.0427)+(((-1.0)*x250*x254))+(((0.3)*x246))+(((0.186)*x243))+(((-1.0)*x246*x254))+(((-1.0)*pp))+(((1.24)*x253))+(((0.3)*x250)));
evalcond[4]=((0.15)+(((-1.0)*x246))+(((-1.0)*x243*x245))+((x244*x249))+((x244*x248))+(((-0.62)*x243))+((x243*x247))+(((-1.0)*x250)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1046=cj3*cj3;
IkReal x1047=(cj0*px);
IkReal x1048=((0.2)*cj3);
IkReal x1049=(py*sj0);
IkReal x1050=(cj3*sj3);
IkReal x1051=((0.64)*sj3);
CheckValue<IkReal> x1052=IKPowWithIntegerCheck(IKsign(((-0.093)+(((0.2)*pz*sj3))+(((0.64)*cj3*pz))+((x1048*x1049))+(((0.096)*sj3))+(((0.62)*x1049))+(((0.62)*x1047))+((x1047*x1048))+(((-1.0)*x1049*x1051))+(((-0.03)*cj3))+(((-1.0)*x1047*x1051)))),-1);
if(!x1052.valid){
continue;
}
CheckValue<IkReal> x1053 = IKatan2WithCheck(IkReal(((-0.794)+(((-0.248)*cj3))+(((0.7936)*sj3))+(((0.256)*x1050))+(((0.3696)*x1046))+(pz*pz))),IkReal(((-0.128)+(((-0.3696)*x1050))+(((0.256)*x1046))+(((0.3968)*cj3))+(((-0.15)*pz))+((pz*x1049))+((pz*x1047))+(((0.124)*sj3)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1053.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1052.value)))+(x1053.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1054=IKsin(j1);
IkReal x1055=IKcos(j1);
IkReal x1056=((0.2)*cj3);
IkReal x1057=(cj0*px);
IkReal x1058=((0.64)*sj3);
IkReal x1059=((0.2)*sj3);
IkReal x1060=((0.64)*cj3);
IkReal x1061=(py*sj0);
IkReal x1062=((1.0)*x1054);
IkReal x1063=((1.0)*x1055);
IkReal x1064=(pz*x1055);
IkReal x1065=((1.24)*x1054);
evalcond[0]=((-0.62)+(((-1.0)*x1056))+x1058+x1064+(((-1.0)*x1057*x1062))+(((-1.0)*x1061*x1062))+(((0.15)*x1054)));
evalcond[1]=(x1059+x1060+(((-1.0)*pz*x1062))+(((-1.0)*x1057*x1063))+(((-1.0)*x1061*x1063))+(((0.15)*x1055)));
evalcond[2]=(((x1054*x1059))+((x1055*x1056))+((x1054*x1060))+(((-1.0)*pz))+(((-1.0)*x1055*x1058))+(((0.62)*x1055)));
evalcond[3]=((0.0427)+(((0.3)*x1061))+(((0.3)*x1057))+(((-1.0)*pp))+(((-1.0)*x1057*x1065))+(((-1.0)*x1061*x1065))+(((0.186)*x1054))+(((1.24)*x1064)));
evalcond[4]=((0.15)+((x1054*x1058))+((x1055*x1060))+((x1055*x1059))+(((-0.62)*x1054))+(((-1.0)*x1054*x1056))+(((-1.0)*x1057))+(((-1.0)*x1061)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1066=cj3*cj3;
IkReal x1067=(py*sj0);
IkReal x1068=((0.2)*sj3);
IkReal x1069=((0.64)*cj3);
IkReal x1070=((1.0)*pz);
IkReal x1071=(cj3*sj3);
IkReal x1072=(cj0*px);
CheckValue<IkReal> x1073 = IKatan2WithCheck(IkReal(((-0.128)+(((0.15)*pz))+(((-0.3696)*x1071))+(((0.256)*x1066))+(((-1.0)*x1070*x1072))+(((0.3968)*cj3))+(((0.124)*sj3))+(((-1.0)*x1067*x1070)))),IkReal(((-0.04)+(((-0.3696)*x1066))+(pz*pz)+(((-0.256)*x1071)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1073.valid){
continue;
}
CheckValue<IkReal> x1074=IKPowWithIntegerCheck(IKsign(((((0.2)*cj3*pz))+(((0.03)*sj3))+(((-0.64)*pz*sj3))+(((-1.0)*x1068*x1072))+(((0.62)*pz))+(((-1.0)*x1067*x1069))+(((-1.0)*x1067*x1068))+(((0.096)*cj3))+(((-1.0)*x1069*x1072)))),-1);
if(!x1074.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1073.value)+(((1.5707963267949)*(x1074.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1075=IKsin(j1);
IkReal x1076=IKcos(j1);
IkReal x1077=((0.2)*cj3);
IkReal x1078=(cj0*px);
IkReal x1079=((0.64)*sj3);
IkReal x1080=((0.2)*sj3);
IkReal x1081=((0.64)*cj3);
IkReal x1082=(py*sj0);
IkReal x1083=((1.0)*x1075);
IkReal x1084=((1.0)*x1076);
IkReal x1085=(pz*x1076);
IkReal x1086=((1.24)*x1075);
evalcond[0]=((-0.62)+x1079+x1085+(((-1.0)*x1078*x1083))+(((-1.0)*x1082*x1083))+(((-1.0)*x1077))+(((0.15)*x1075)));
evalcond[1]=((((-1.0)*pz*x1083))+x1081+x1080+(((-1.0)*x1078*x1084))+(((-1.0)*x1082*x1084))+(((0.15)*x1076)));
evalcond[2]=((((-1.0)*x1076*x1079))+((x1075*x1081))+((x1075*x1080))+(((0.62)*x1076))+(((-1.0)*pz))+((x1076*x1077)));
evalcond[3]=((0.0427)+(((1.24)*x1085))+(((0.3)*x1078))+(((-1.0)*x1078*x1086))+(((0.186)*x1075))+(((-1.0)*pp))+(((-1.0)*x1082*x1086))+(((0.3)*x1082)));
evalcond[4]=((0.15)+(((-1.0)*x1075*x1077))+((x1076*x1080))+((x1076*x1081))+(((-0.62)*x1075))+((x1075*x1079))+(((-1.0)*x1082))+(((-1.0)*x1078)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[2], cj3array[2], sj3array[2];
bool j3valid[2]={false};
_nj3 = 2;
if( (((0.976008697297665)+(((0.360816523954774)*cj0*px))+(((-1.20272174651591)*pp))+(((0.360816523954774)*py*sj0)))) < -1-IKFAST_SINCOS_THRESH || (((0.976008697297665)+(((0.360816523954774)*cj0*px))+(((-1.20272174651591)*pp))+(((0.360816523954774)*py*sj0)))) > 1+IKFAST_SINCOS_THRESH )
    continue;
IkReal x1087=IKasin(((0.976008697297665)+(((0.360816523954774)*cj0*px))+(((-1.20272174651591)*pp))+(((0.360816523954774)*py*sj0))));
j3array[0]=((-2.83870778521482)+(((-1.0)*x1087)));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
j3array[1]=((0.302884868374971)+x1087);
sj3array[1]=IKsin(j3array[1]);
cj3array[1]=IKcos(j3array[1]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
if( j3array[1] > IKPI )
{
    j3array[1]-=IK2PI;
}
else if( j3array[1] < -IKPI )
{    j3array[1]+=IK2PI;
}
j3valid[1] = true;
for(int ij3 = 0; ij3 < 2; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 2; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];

{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x1088=cj3*cj3;
IkReal x1089=(py*sj0);
IkReal x1090=((0.2)*sj3);
IkReal x1091=((21.3333333333333)*cj3);
IkReal x1092=((6.66666666666667)*sj3);
IkReal x1093=(cj3*pz);
IkReal x1094=(cj3*sj3);
IkReal x1095=(cj0*px);
IkReal x1096=((0.64)*cj3);
IkReal x1097=(pz*sj3);
j1eval[0]=(sj3+(((-1.0)*x1091*x1095))+(((-6.66666666666667)*x1093))+(((-1.0)*x1089*x1091))+(((-1.0)*x1089*x1092))+(((21.3333333333333)*x1097))+(((-20.6666666666667)*pz))+(((3.2)*cj3))+(((-1.0)*x1092*x1095)));
j1eval[1]=IKsign(((((0.03)*sj3))+(((-1.0)*x1090*x1095))+(((0.64)*x1097))+(((-0.62)*pz))+(((-1.0)*x1089*x1090))+(((-1.0)*x1089*x1096))+(((-0.2)*x1093))+(((-1.0)*x1095*x1096))+(((0.096)*cj3))));
j1eval[2]=((IKabs(((-0.128)+((pz*x1089))+(((0.256)*x1088))+(((0.3968)*cj3))+(((-0.15)*pz))+(((0.124)*sj3))+(((-0.3696)*x1094))+((pz*x1095)))))+(IKabs(((0.04)+(((0.3696)*x1088))+(((-1.0)*(pz*pz)))+(((0.256)*x1094))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x1098=(cj0*px);
IkReal x1099=(pz*sj3);
IkReal x1100=(py*sj0);
IkReal x1101=((0.64)*sj3);
IkReal x1102=((6.66666666666667)*cj3);
IkReal x1103=((21.3333333333333)*sj3);
IkReal x1104=((0.2)*cj3);
IkReal x1105=(cj3*pz);
j1eval[0]=((3.1)+(((-1.0)*x1098*x1102))+((x1098*x1103))+cj3+(((21.3333333333333)*x1105))+(((-20.6666666666667)*x1100))+(((-3.2)*sj3))+(((-1.0)*x1100*x1102))+(((-20.6666666666667)*x1098))+((x1100*x1103))+(((6.66666666666667)*x1099)));
j1eval[1]=IKsign(((0.093)+(((-0.096)*sj3))+(((-1.0)*x1098*x1104))+((x1098*x1101))+(((0.64)*x1105))+(((0.03)*cj3))+(((-0.62)*x1100))+(((-1.0)*x1100*x1104))+((x1100*x1101))+(((0.2)*x1099))+(((-0.62)*x1098))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x1106=py*py;
IkReal x1107=cj0*cj0;
IkReal x1108=px*px;
IkReal x1109=pz*pz;
IkReal x1110=(cj0*px);
IkReal x1111=(py*sj0);
IkReal x1112=(x1106*x1107);
IkReal x1113=(x1107*x1108);
j1eval[0]=((-1.0)+(((44.4444444444444)*x1112))+(((-88.8888888888889)*x1110*x1111))+(((13.3333333333333)*x1110))+(((13.3333333333333)*x1111))+(((-44.4444444444444)*x1109))+(((-44.4444444444444)*x1106))+(((-44.4444444444444)*x1113)));
j1eval[1]=IKsign(((-0.0225)+(((0.3)*x1111))+(((0.3)*x1110))+x1112+(((-1.0)*x1109))+(((-1.0)*x1106))+(((-1.0)*x1113))+(((-2.0)*x1110*x1111))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1114=py*py;
IkReal x1115=cj0*cj0;
IkReal x1116=(cj0*px);
IkReal x1117=(cj3*pz);
IkReal x1118=(pz*sj3);
IkReal x1119=(py*sj0);
IkReal x1120=((0.64)*cj3);
IkReal x1121=((0.64)*sj3);
IkReal x1122=((0.2)*x1119);
CheckValue<IkReal> x1123=IKPowWithIntegerCheck(IKsign(((-0.0225)+(((0.3)*x1119))+(((0.3)*x1116))+((x1114*x1115))+(((-2.0)*x1116*x1119))+(((-1.0)*x1115*(px*px)))+(((-1.0)*x1114))+(((-1.0)*(pz*pz))))),-1);
if(!x1123.valid){
continue;
}
CheckValue<IkReal> x1124 = IKatan2WithCheck(IkReal(((-0.093)+(((0.64)*x1117))+(((-1.0)*x1116*x1121))+(((0.2)*cj3*x1116))+(((0.096)*sj3))+(((-1.0)*x1119*x1121))+(((0.62)*x1116))+(((0.62)*x1119))+(((-0.03)*cj3))+(((0.2)*x1118))+((cj3*x1122)))),IkReal(((((-0.03)*sj3))+(((0.64)*x1118))+(((0.2)*sj3*x1116))+(((-0.62)*pz))+(((-0.096)*cj3))+((x1119*x1120))+(((-0.2)*x1117))+((sj3*x1122))+((x1116*x1120)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1124.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1123.value)))+(x1124.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1125=IKcos(j1);
IkReal x1126=IKsin(j1);
IkReal x1127=((0.2)*cj3);
IkReal x1128=(cj0*px);
IkReal x1129=((0.64)*sj3);
IkReal x1130=((0.2)*sj3);
IkReal x1131=((0.64)*cj3);
IkReal x1132=(py*sj0);
IkReal x1133=((1.0)*x1126);
IkReal x1134=(pz*x1125);
IkReal x1135=((1.24)*x1126);
evalcond[0]=(x1131+x1130+((pz*x1126))+((x1125*x1128))+((x1125*x1132))+(((-0.15)*x1125)));
evalcond[1]=((-0.62)+x1129+x1134+(((-1.0)*x1132*x1133))+(((-1.0)*x1127))+(((0.15)*x1126))+(((-1.0)*x1128*x1133)));
evalcond[2]=((((-1.0)*x1126*x1130))+(((-1.0)*x1126*x1131))+((x1125*x1127))+(((-1.0)*pz))+(((0.62)*x1125))+(((-1.0)*x1125*x1129)));
evalcond[3]=((0.0427)+(((1.24)*x1134))+(((-1.0)*pp))+(((0.3)*x1132))+(((0.186)*x1126))+(((-1.0)*x1132*x1135))+(((0.3)*x1128))+(((-1.0)*x1128*x1135)));
evalcond[4]=((0.15)+(((-1.0)*x1126*x1127))+(((-0.62)*x1126))+(((-1.0)*x1128))+(((-1.0)*x1132))+(((-1.0)*x1125*x1130))+(((-1.0)*x1125*x1131))+((x1126*x1129)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1136=cj3*cj3;
IkReal x1137=((0.2)*cj3);
IkReal x1138=(cj0*px);
IkReal x1139=(py*sj0);
IkReal x1140=(cj3*sj3);
IkReal x1141=((0.64)*sj3);
IkReal x1142=((1.0)*pz);
CheckValue<IkReal> x1143=IKPowWithIntegerCheck(IKsign(((0.093)+(((0.2)*pz*sj3))+(((-0.096)*sj3))+(((0.64)*cj3*pz))+(((0.03)*cj3))+(((-0.62)*x1138))+(((-0.62)*x1139))+((x1139*x1141))+(((-1.0)*x1137*x1138))+(((-1.0)*x1137*x1139))+((x1138*x1141)))),-1);
if(!x1143.valid){
continue;
}
CheckValue<IkReal> x1144 = IKatan2WithCheck(IkReal(((0.794)+(((-0.3696)*x1136))+(((-0.256)*x1140))+(((-1.0)*pz*x1142))+(((-0.7936)*sj3))+(((0.248)*cj3)))),IkReal(((-0.128)+(((0.15)*pz))+(((0.256)*x1136))+(((0.3968)*cj3))+(((-0.3696)*x1140))+(((0.124)*sj3))+(((-1.0)*x1139*x1142))+(((-1.0)*x1138*x1142)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1144.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1143.value)))+(x1144.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1145=IKcos(j1);
IkReal x1146=IKsin(j1);
IkReal x1147=((0.2)*cj3);
IkReal x1148=(cj0*px);
IkReal x1149=((0.64)*sj3);
IkReal x1150=((0.2)*sj3);
IkReal x1151=((0.64)*cj3);
IkReal x1152=(py*sj0);
IkReal x1153=((1.0)*x1146);
IkReal x1154=(pz*x1145);
IkReal x1155=((1.24)*x1146);
evalcond[0]=(((x1145*x1148))+x1151+x1150+((pz*x1146))+((x1145*x1152))+(((-0.15)*x1145)));
evalcond[1]=((-0.62)+x1149+x1154+(((-1.0)*x1147))+(((0.15)*x1146))+(((-1.0)*x1152*x1153))+(((-1.0)*x1148*x1153)));
evalcond[2]=(((x1145*x1147))+(((-1.0)*x1145*x1149))+(((0.62)*x1145))+(((-1.0)*pz))+(((-1.0)*x1146*x1150))+(((-1.0)*x1146*x1151)));
evalcond[3]=((0.0427)+(((0.3)*x1152))+(((0.3)*x1148))+(((0.186)*x1146))+(((-1.0)*pp))+(((1.24)*x1154))+(((-1.0)*x1152*x1155))+(((-1.0)*x1148*x1155)));
evalcond[4]=((0.15)+((x1146*x1149))+(((-1.0)*x1146*x1147))+(((-1.0)*x1148))+(((-1.0)*x1152))+(((-0.62)*x1146))+(((-1.0)*x1145*x1150))+(((-1.0)*x1145*x1151)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1156=cj3*cj3;
IkReal x1157=(py*sj0);
IkReal x1158=((0.2)*sj3);
IkReal x1159=((0.64)*cj3);
IkReal x1160=(cj3*sj3);
IkReal x1161=(cj0*px);
CheckValue<IkReal> x1162 = IKatan2WithCheck(IkReal(((-0.128)+((pz*x1157))+(((0.3968)*cj3))+(((-0.15)*pz))+(((0.124)*sj3))+((pz*x1161))+(((0.256)*x1156))+(((-0.3696)*x1160)))),IkReal(((0.04)+(((0.3696)*x1156))+(((0.256)*x1160))+(((-1.0)*(pz*pz))))),IKFAST_ATAN2_MAGTHRESH);
if(!x1162.valid){
continue;
}
CheckValue<IkReal> x1163=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1157*x1159))+(((-1.0)*x1157*x1158))+(((-1.0)*x1159*x1161))+(((0.03)*sj3))+(((-1.0)*x1158*x1161))+(((-0.62)*pz))+(((0.64)*pz*sj3))+(((0.096)*cj3))+(((-0.2)*cj3*pz)))),-1);
if(!x1163.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1162.value)+(((1.5707963267949)*(x1163.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1164=IKcos(j1);
IkReal x1165=IKsin(j1);
IkReal x1166=((0.2)*cj3);
IkReal x1167=(cj0*px);
IkReal x1168=((0.64)*sj3);
IkReal x1169=((0.2)*sj3);
IkReal x1170=((0.64)*cj3);
IkReal x1171=(py*sj0);
IkReal x1172=((1.0)*x1165);
IkReal x1173=(pz*x1164);
IkReal x1174=((1.24)*x1165);
evalcond[0]=(((x1164*x1171))+x1169+x1170+((x1164*x1167))+(((-0.15)*x1164))+((pz*x1165)));
evalcond[1]=((-0.62)+x1168+x1173+(((-1.0)*x1171*x1172))+(((-1.0)*x1167*x1172))+(((-1.0)*x1166))+(((0.15)*x1165)));
evalcond[2]=((((-1.0)*x1165*x1170))+((x1164*x1166))+(((-1.0)*pz))+(((-1.0)*x1164*x1168))+(((0.62)*x1164))+(((-1.0)*x1165*x1169)));
evalcond[3]=((0.0427)+(((-1.0)*x1171*x1174))+(((-1.0)*pp))+(((-1.0)*x1167*x1174))+(((0.3)*x1171))+(((0.186)*x1165))+(((1.24)*x1173))+(((0.3)*x1167)));
evalcond[4]=((0.15)+((x1165*x1168))+(((-0.62)*x1165))+(((-1.0)*x1164*x1170))+(((-1.0)*x1164*x1169))+(((-1.0)*x1167))+(((-1.0)*x1165*x1166))+(((-1.0)*x1171)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1, j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1175=cj0*cj0;
IkReal x1176=py*py;
IkReal x1177=px*px;
IkReal x1178=((7.5)*sj2);
IkReal x1179=(cj0*px);
IkReal x1180=(cj2*py);
IkReal x1181=((31.0)*px);
IkReal x1182=(cj2*sj0);
IkReal x1183=(pp*sj2);
IkReal x1184=((31.0)*x1176);
IkReal x1185=(py*sj0*sj2);
IkReal x1186=((31.0)*x1177);
IkReal x1187=(sj2*x1175);
CheckValue<IkReal> x1188 = IKatan2WithCheck(IkReal(((((25.0)*py*sj0*x1183))+(((25.0)*x1179*x1183))+((pz*x1181*x1182))+((x1175*x1176*x1178))+(((-31.0)*cj0*pz*x1180))+(((0.160125)*sj2))+(((-15.0)*x1179*x1185))+(((-1.0)*x1176*x1178))+(((0.0575)*sj2*x1179))+(((0.0575)*x1185))+(((-1.0)*x1175*x1177*x1178))+(((-3.75)*x1183)))),IkReal((((x1180*x1181))+(((-4.65)*px*x1182))+(((1.0675)*pz*sj2))+(((-1.0)*cj0*x1182*x1184))+((pz*x1178*x1179))+(((4.65)*cj0*x1180))+(((-62.0)*px*x1175*x1180))+((cj0*x1182*x1186))+(((-25.0)*pz*x1183))+((py*pz*sj0*x1178)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1188.valid){
continue;
}
CheckValue<IkReal> x1189=IKPowWithIntegerCheck(IKsign((((x1184*x1187))+(((-0.6975)*sj2))+(((-1.0)*x1186*x1187))+(((9.3)*sj2*x1179))+(((-62.0)*x1179*x1185))+(((9.3)*x1185))+(((-1.0)*sj2*x1184))+(((-31.0)*sj2*(pz*pz))))),-1);
if(!x1189.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1188.value)+(((1.5707963267949)*(x1189.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[2];
IkReal x1190=IKcos(j1);
IkReal x1191=IKsin(j1);
IkReal x1192=(cj0*px);
IkReal x1193=(py*sj0);
IkReal x1194=(sj2*x1190);
IkReal x1195=((1.24)*x1191);
evalcond[0]=((((-1.0)*cj0*cj2*py))+((x1192*x1194))+((x1193*x1194))+((pz*sj2*x1191))+(((-0.15)*x1194))+((cj2*px*sj0)));
evalcond[1]=((0.0427)+(((-1.0)*x1193*x1195))+(((0.3)*x1193))+(((0.3)*x1192))+(((-1.0)*pp))+(((0.186)*x1191))+(((1.24)*pz*x1190))+(((-1.0)*x1192*x1195)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j3eval[3];
IkReal x1196=(pp*sj2);
IkReal x1197=(px*sj0);
IkReal x1198=(cj0*py);
IkReal x1199=(cj0*px*sj2);
IkReal x1200=(py*sj0*sj2);
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
j3eval[2]=((IKabs(((((3125.0)*x1196))+(((12400.0)*x1198))+(((-937.5)*x1199))+(((-12400.0)*x1197))+(((-937.5)*x1200))+(((-2535.9375)*sj2)))))+(IKabs(((((8115.0)*sj2))+(((-3875.0)*x1197))+(((3000.0)*x1200))+(((-10000.0)*x1196))+(((3875.0)*x1198))+(((3000.0)*x1199))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
IkReal x1201=(cj1*sj2);
j3eval[0]=x1201;
j3eval[1]=IKsign(x1201);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1202=(pz*sj1);
IkReal x1203=(py*sj0);
IkReal x1204=(cj0*px);
IkReal x1205=(cj1*x1204);
if( IKabs(((0.931580759958673)+(((-0.0667259786476868)*cj1))+(((0.344392147859029)*x1204))+(((0.344392147859029)*x1203))+(((0.444839857651246)*cj1*x1203))+(((-1.14797382619676)*pp))+(((0.444839857651246)*x1205))+(((0.444839857651246)*x1202)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.291118987487085)+(((0.358741820686488)*pp))+(((-0.213523131672598)*cj1))+(((1.42348754448399)*x1205))+(((1.42348754448399)*x1202))+(((-0.107622546205947)*x1204))+(((-0.107622546205947)*x1203))+(((1.42348754448399)*cj1*x1203)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.931580759958673)+(((-0.0667259786476868)*cj1))+(((0.344392147859029)*x1204))+(((0.344392147859029)*x1203))+(((0.444839857651246)*cj1*x1203))+(((-1.14797382619676)*pp))+(((0.444839857651246)*x1205))+(((0.444839857651246)*x1202))))+IKsqr(((-0.291118987487085)+(((0.358741820686488)*pp))+(((-0.213523131672598)*cj1))+(((1.42348754448399)*x1205))+(((1.42348754448399)*x1202))+(((-0.107622546205947)*x1204))+(((-0.107622546205947)*x1203))+(((1.42348754448399)*cj1*x1203))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.931580759958673)+(((-0.0667259786476868)*cj1))+(((0.344392147859029)*x1204))+(((0.344392147859029)*x1203))+(((0.444839857651246)*cj1*x1203))+(((-1.14797382619676)*pp))+(((0.444839857651246)*x1205))+(((0.444839857651246)*x1202))), ((-0.291118987487085)+(((0.358741820686488)*pp))+(((-0.213523131672598)*cj1))+(((1.42348754448399)*x1205))+(((1.42348754448399)*x1202))+(((-0.107622546205947)*x1204))+(((-0.107622546205947)*x1203))+(((1.42348754448399)*cj1*x1203))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1206=IKsin(j3);
IkReal x1207=IKcos(j3);
IkReal x1208=(cj0*px);
IkReal x1209=((0.241935483870968)*sj0);
IkReal x1210=((0.2)*sj1);
IkReal x1211=((0.2)*cj1);
IkReal x1212=((1.0)*pz);
IkReal x1213=((0.64)*x1207);
IkReal x1214=((0.64)*x1206);
IkReal x1215=((1.0)*py*sj0);
evalcond[0]=((0.8115)+(((0.248)*x1207))+(((-0.7936)*x1206))+(((0.3)*x1208))+(((-1.0)*pp))+(((0.3)*py*sj0)));
CheckValue<IkReal> x1216=IKPowWithIntegerCheck(py,-1);
if(!x1216.valid){
continue;
}
evalcond[1]=((-0.654435483870968)+x1214+(((-0.2)*x1207))+(((0.806451612903226)*pp))+(((-1.0)*x1209*(px*px)*(x1216.value)))+(((-1.0)*py*x1209)));
evalcond[2]=((((-1.0)*cj1*x1208))+x1213+(((-1.0)*cj1*x1215))+(((-1.0)*sj1*x1212))+(((0.15)*cj1))+(((0.2)*x1206)));
evalcond[3]=((((-1.0)*cj1*x1214))+((x1207*x1211))+(((0.62)*cj1))+((x1206*x1210))+((sj1*x1213))+(((-1.0)*x1212)));
evalcond[4]=((0.15)+(((-1.0)*x1207*x1210))+((x1206*x1211))+(((-0.62)*sj1))+(((-1.0)*x1208))+((sj1*x1214))+(((-1.0)*x1215))+((cj1*x1213)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1217=(cj0*px);
IkReal x1218=((1.42348754448399)*cj1);
IkReal x1219=(pz*sj1);
IkReal x1220=((0.444839857651246)*cj1);
IkReal x1221=(py*sj0);
if( IKabs(((0.931580759958673)+(((0.344392147859029)*x1217))+(((-1.0)*x1220*x1221))+(((0.0667259786476868)*cj1))+(((-0.444839857651246)*x1219))+(((-1.0)*x1217*x1220))+(((0.344392147859029)*x1221))+(((-1.14797382619676)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.291118987487085)+(((0.358741820686488)*pp))+(((-1.42348754448399)*x1219))+(((-1.0)*x1218*x1221))+(((-0.107622546205947)*x1221))+(((-1.0)*x1217*x1218))+(((0.213523131672598)*cj1))+(((-0.107622546205947)*x1217)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.931580759958673)+(((0.344392147859029)*x1217))+(((-1.0)*x1220*x1221))+(((0.0667259786476868)*cj1))+(((-0.444839857651246)*x1219))+(((-1.0)*x1217*x1220))+(((0.344392147859029)*x1221))+(((-1.14797382619676)*pp))))+IKsqr(((-0.291118987487085)+(((0.358741820686488)*pp))+(((-1.42348754448399)*x1219))+(((-1.0)*x1218*x1221))+(((-0.107622546205947)*x1221))+(((-1.0)*x1217*x1218))+(((0.213523131672598)*cj1))+(((-0.107622546205947)*x1217))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.931580759958673)+(((0.344392147859029)*x1217))+(((-1.0)*x1220*x1221))+(((0.0667259786476868)*cj1))+(((-0.444839857651246)*x1219))+(((-1.0)*x1217*x1220))+(((0.344392147859029)*x1221))+(((-1.14797382619676)*pp))), ((-0.291118987487085)+(((0.358741820686488)*pp))+(((-1.42348754448399)*x1219))+(((-1.0)*x1218*x1221))+(((-0.107622546205947)*x1221))+(((-1.0)*x1217*x1218))+(((0.213523131672598)*cj1))+(((-0.107622546205947)*x1217))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1222=IKsin(j3);
IkReal x1223=IKcos(j3);
IkReal x1224=(cj0*px);
IkReal x1225=((0.241935483870968)*sj0);
IkReal x1226=((0.2)*sj1);
IkReal x1227=((0.2)*cj1);
IkReal x1228=(py*sj0);
IkReal x1229=((0.64)*x1223);
IkReal x1230=((0.64)*x1222);
evalcond[0]=((0.8115)+(((0.3)*x1228))+(((0.3)*x1224))+(((-1.0)*pp))+(((-0.7936)*x1222))+(((0.248)*x1223)));
evalcond[1]=((((-0.15)*cj1))+x1229+(((0.2)*x1222))+((pz*sj1))+((cj1*x1224))+((cj1*x1228)));
CheckValue<IkReal> x1231=IKPowWithIntegerCheck(py,-1);
if(!x1231.valid){
continue;
}
evalcond[2]=((-0.654435483870968)+(((-1.0)*x1225*(px*px)*(x1231.value)))+x1230+(((-1.0)*py*x1225))+(((0.806451612903226)*pp))+(((-0.2)*x1223)));
evalcond[3]=(((x1223*x1227))+(((0.62)*cj1))+(((-1.0)*x1222*x1226))+(((-1.0)*pz))+(((-1.0)*sj1*x1229))+(((-1.0)*cj1*x1230)));
evalcond[4]=((0.15)+((sj1*x1230))+(((-1.0)*x1228))+(((-1.0)*x1224))+(((-1.0)*x1222*x1227))+(((-0.62)*sj1))+(((-1.0)*cj1*x1229))+(((-1.0)*x1223*x1226)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x1232=cj2*cj2;
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
j3eval[2]=(x1232+(((2.22434647310404)*x1232*(pp*pp)))+(((1.96543254363473)*(pz*pz)))+(((-2.98284862043251)*pp*x1232)));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x1233=(pp*sj2);
IkReal x1234=(px*sj0);
IkReal x1235=(cj0*py);
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
j3eval[2]=((IKabs(((((12400.0)*x1235))+(((4122.34042553191)*x1233))+(((-2764.02925531915)*sj2))+(((-12400.0)*x1234)))))+(IKabs(((((-3875.0)*x1234))+(((-13191.4893617021)*x1233))+(((8844.89361702128)*sj2))+(((3875.0)*x1235))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj1=1.0;
cj1=0;
j1=1.5707963267949;
IkReal x1236=(pp*sj2);
IkReal x1237=(px*sj0);
IkReal x1238=(cj0*py);
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
j3eval[2]=((IKabs(((((132.978723404255)*x1236))+(((400.0)*x1238))+(((-89.1622340425532)*sj2))+(((-400.0)*x1237)))))+(IKabs(((((-125.0)*x1237))+(((-425.531914893617)*x1236))+(((125.0)*x1238))+(((285.31914893617)*sj2))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((1.01537063678352)+(((0.444839857651246)*pz))+(((-1.51434845157871)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.317303323994851)+(((0.473233891118346)*pp))+(((1.42348754448399)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((1.01537063678352)+(((0.444839857651246)*pz))+(((-1.51434845157871)*pp))))+IKsqr(((-0.317303323994851)+(((0.473233891118346)*pp))+(((1.42348754448399)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((1.01537063678352)+(((0.444839857651246)*pz))+(((-1.51434845157871)*pp))), ((-0.317303323994851)+(((0.473233891118346)*pp))+(((1.42348754448399)*pz))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1239=IKcos(j3);
IkReal x1240=IKsin(j3);
evalcond[0]=((((0.2)*x1240))+(((-1.0)*pz))+(((0.64)*x1239)));
evalcond[1]=((0.884489361702128)+(((-0.7936)*x1240))+(((0.248)*x1239))+(((-1.31914893617021)*pp)));
evalcond[2]=((-0.713297872340426)+(((-0.2)*x1239))+(((0.64)*x1240))+(((1.06382978723404)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((1.01537063678352)+(((-0.444839857651246)*pz))+(((-1.51434845157871)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((1.01537063678352)+(((-0.444839857651246)*pz))+(((-1.51434845157871)*pp))))+IKsqr(((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((1.01537063678352)+(((-0.444839857651246)*pz))+(((-1.51434845157871)*pp))), ((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*pz))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1241=IKcos(j3);
IkReal x1242=IKsin(j3);
evalcond[0]=((((-0.64)*x1241))+(((-0.2)*x1242))+(((-1.0)*pz)));
evalcond[1]=((0.884489361702128)+(((-0.7936)*x1242))+(((-1.31914893617021)*pp))+(((0.248)*x1241)));
evalcond[2]=((-0.713297872340426)+(((-0.2)*x1241))+(((0.64)*x1242))+(((1.06382978723404)*pp)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1243=(cj0*py);
IkReal x1244=(px*sj0);
if( IKabs(((1.01537063678352)+(((0.444839857651246)*x1243))+(((-0.444839857651246)*x1244))+(((-1.51434845157871)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1244))+(((1.42348754448399)*x1243)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((1.01537063678352)+(((0.444839857651246)*x1243))+(((-0.444839857651246)*x1244))+(((-1.51434845157871)*pp))))+IKsqr(((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1244))+(((1.42348754448399)*x1243))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((1.01537063678352)+(((0.444839857651246)*x1243))+(((-0.444839857651246)*x1244))+(((-1.51434845157871)*pp))), ((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1244))+(((1.42348754448399)*x1243))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1245=IKsin(j3);
IkReal x1246=IKcos(j3);
evalcond[0]=((0.884489361702128)+(((-0.7936)*x1245))+(((-1.31914893617021)*pp))+(((0.248)*x1246)));
evalcond[1]=((-0.713297872340426)+(((-0.2)*x1246))+(((0.64)*x1245))+(((1.06382978723404)*pp)));
evalcond[2]=((((-0.64)*x1246))+(((-0.2)*x1245))+(((-1.0)*px*sj0))+((cj0*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1247=(cj0*py);
IkReal x1248=(px*sj0);
if( IKabs(((1.01537063678352)+(((0.444839857651246)*x1248))+(((-0.444839857651246)*x1247))+(((-1.51434845157871)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1247))+(((1.42348754448399)*x1248)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((1.01537063678352)+(((0.444839857651246)*x1248))+(((-0.444839857651246)*x1247))+(((-1.51434845157871)*pp))))+IKsqr(((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1247))+(((1.42348754448399)*x1248))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((1.01537063678352)+(((0.444839857651246)*x1248))+(((-0.444839857651246)*x1247))+(((-1.51434845157871)*pp))), ((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1247))+(((1.42348754448399)*x1248))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1249=IKsin(j3);
IkReal x1250=IKcos(j3);
evalcond[0]=((0.884489361702128)+(((-0.7936)*x1249))+(((0.248)*x1250))+(((-1.31914893617021)*pp)));
evalcond[1]=((-0.713297872340426)+(((0.64)*x1249))+(((1.06382978723404)*pp))+(((-0.2)*x1250)));
evalcond[2]=((((0.64)*x1250))+(((0.2)*x1249))+(((-1.0)*px*sj0))+((cj0*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1251=pp;
IkReal x1252=pp*pp;
IkReal x1253=pz*pz;
IkReal x1254=x1251*x1251;
CheckValue<IkReal> x1257=IKPowWithIntegerCheck(((1.0)+(((4.94771723241037)*x1252*x1254))+(((2.22434647310404)*x1252))+(((2.22434647310404)*x1254))+(((8.89738589241615)*pp*x1251))+(((-6.6348888086623)*pp*x1254))+(((-6.6348888086623)*x1251*x1252))+(((-2.98284862043251)*x1251))+(((-2.98284862043251)*pp))),-1);
if(!x1257.valid){
continue;
}
IkReal x1255=x1257.value;
IkReal x1256=(x1253*x1255);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((5.86258775133401)*x1251*x1256))+(((-1.96543254363473)*x1256))+(((-4.3718029465578)*x1254*x1256)))))+(IKabs(cj2))+(IKabs(((-1.0)+(IKsign(sj2)))))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1258=(cj0*py);
IkReal x1259=(px*sj0);
if( IKabs(((1.01537063678352)+(((0.444839857651246)*x1258))+(((-0.444839857651246)*x1259))+(((-1.51434845157871)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1259))+(((1.42348754448399)*x1258)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((1.01537063678352)+(((0.444839857651246)*x1258))+(((-0.444839857651246)*x1259))+(((-1.51434845157871)*pp))))+IKsqr(((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1259))+(((1.42348754448399)*x1258))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((1.01537063678352)+(((0.444839857651246)*x1258))+(((-0.444839857651246)*x1259))+(((-1.51434845157871)*pp))), ((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1259))+(((1.42348754448399)*x1258))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1260=IKsin(j3);
IkReal x1261=IKcos(j3);
evalcond[0]=((0.884489361702128)+(((0.248)*x1261))+(((-0.7936)*x1260))+(((-1.31914893617021)*pp)));
evalcond[1]=((-0.713297872340426)+(((0.64)*x1260))+(((1.06382978723404)*pp))+(((-0.2)*x1261)));
evalcond[2]=((((-0.64)*x1261))+(((-0.2)*x1260))+(((-1.0)*px*sj0))+((cj0*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1262=pp;
IkReal x1263=pp*pp;
IkReal x1264=pz*pz;
IkReal x1265=x1262*x1262;
CheckValue<IkReal> x1268=IKPowWithIntegerCheck(((1.0)+(((2.22434647310404)*x1265))+(((2.22434647310404)*x1263))+(((4.94771723241037)*x1263*x1265))+(((8.89738589241615)*pp*x1262))+(((-6.6348888086623)*x1262*x1263))+(((-6.6348888086623)*pp*x1265))+(((-2.98284862043251)*x1262))+(((-2.98284862043251)*pp))),-1);
if(!x1268.valid){
continue;
}
IkReal x1266=x1268.value;
IkReal x1267=(x1264*x1266);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-1.96543254363473)*x1267))+(((5.86258775133401)*x1262*x1267))+(((-4.3718029465578)*x1265*x1267)))))+(IKabs(cj2))+(IKabs(((1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1269=(cj0*py);
IkReal x1270=(px*sj0);
if( IKabs(((1.01537063678352)+(((0.444839857651246)*x1270))+(((-0.444839857651246)*x1269))+(((-1.51434845157871)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1269))+(((1.42348754448399)*x1270)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((1.01537063678352)+(((0.444839857651246)*x1270))+(((-0.444839857651246)*x1269))+(((-1.51434845157871)*pp))))+IKsqr(((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1269))+(((1.42348754448399)*x1270))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((1.01537063678352)+(((0.444839857651246)*x1270))+(((-0.444839857651246)*x1269))+(((-1.51434845157871)*pp))), ((-0.317303323994851)+(((0.473233891118346)*pp))+(((-1.42348754448399)*x1269))+(((1.42348754448399)*x1270))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1271=IKsin(j3);
IkReal x1272=IKcos(j3);
evalcond[0]=((0.884489361702128)+(((-0.7936)*x1271))+(((0.248)*x1272))+(((-1.31914893617021)*pp)));
evalcond[1]=((-0.713297872340426)+(((-0.2)*x1272))+(((1.06382978723404)*pp))+(((0.64)*x1271)));
evalcond[2]=((((0.2)*x1271))+(((-1.0)*px*sj0))+((cj0*py))+(((0.64)*x1272)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1273=(pp*sj2);
IkReal x1274=(px*sj0);
IkReal x1275=(cj0*py);
CheckValue<IkReal> x1276 = IKatan2WithCheck(IkReal(((((-425.531914893617)*x1273))+(((-125.0)*x1274))+(((125.0)*x1275))+(((285.31914893617)*sj2)))),IkReal(((((400.0)*x1275))+(((-400.0)*x1274))+(((-89.1622340425532)*sj2))+(((132.978723404255)*x1273)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1276.valid){
continue;
}
CheckValue<IkReal> x1277=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x1277.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1276.value)+(((1.5707963267949)*(x1277.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1278=IKsin(j3);
IkReal x1279=IKcos(j3);
IkReal x1280=(px*sj0);
IkReal x1281=((1.0)*pz);
IkReal x1282=(cj0*py);
IkReal x1283=((0.64)*x1279);
IkReal x1284=((0.2)*x1278);
evalcond[0]=((0.884489361702128)+(((-0.7936)*x1278))+(((0.248)*x1279))+(((-1.31914893617021)*pp)));
evalcond[1]=((-0.713297872340426)+(((-0.2)*x1279))+(((1.06382978723404)*pp))+(((0.64)*x1278)));
evalcond[2]=(((cj2*x1284))+((cj2*x1283))+(((-1.0)*x1281)));
evalcond[3]=((((-1.0)*x1280))+x1282+(((-1.0)*sj2*x1283))+(((-1.0)*sj2*x1284)));
evalcond[4]=((((-1.0)*sj2*x1282))+x1284+x1283+(((-1.0)*cj2*x1281))+((sj2*x1280)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1285=(pp*sj2);
IkReal x1286=(px*sj0);
IkReal x1287=(cj0*py);
CheckValue<IkReal> x1288=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x1288.valid){
continue;
}
CheckValue<IkReal> x1289 = IKatan2WithCheck(IkReal(((((8844.89361702128)*sj2))+(((-13191.4893617021)*x1285))+(((3875.0)*x1287))+(((-3875.0)*x1286)))),IkReal(((((-12400.0)*x1286))+(((4122.34042553191)*x1285))+(((12400.0)*x1287))+(((-2764.02925531915)*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1289.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1288.value)))+(x1289.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1290=IKsin(j3);
IkReal x1291=IKcos(j3);
IkReal x1292=(px*sj0);
IkReal x1293=((1.0)*pz);
IkReal x1294=(cj0*py);
IkReal x1295=((0.64)*x1291);
IkReal x1296=((0.2)*x1290);
evalcond[0]=((0.884489361702128)+(((-0.7936)*x1290))+(((0.248)*x1291))+(((-1.31914893617021)*pp)));
evalcond[1]=((-0.713297872340426)+(((-0.2)*x1291))+(((0.64)*x1290))+(((1.06382978723404)*pp)));
evalcond[2]=(((cj2*x1296))+((cj2*x1295))+(((-1.0)*x1293)));
evalcond[3]=(x1294+(((-1.0)*sj2*x1296))+(((-1.0)*sj2*x1295))+(((-1.0)*x1292)));
evalcond[4]=(x1296+x1295+((sj2*x1292))+(((-1.0)*sj2*x1294))+(((-1.0)*cj2*x1293)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1297=(cj2*pp);
CheckValue<IkReal> x1298=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x1298.valid){
continue;
}
CheckValue<IkReal> x1299 = IKatan2WithCheck(IkReal(((((3875.0)*pz))+(((8844.89361702128)*cj2))+(((-13191.4893617021)*x1297)))),IkReal(((((4122.34042553191)*x1297))+(((-2764.02925531915)*cj2))+(((12400.0)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1299.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1298.value)))+(x1299.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1300=IKsin(j3);
IkReal x1301=IKcos(j3);
IkReal x1302=(px*sj0);
IkReal x1303=((1.0)*pz);
IkReal x1304=(cj0*py);
IkReal x1305=((0.64)*x1301);
IkReal x1306=((0.2)*x1300);
evalcond[0]=((0.884489361702128)+(((-0.7936)*x1300))+(((0.248)*x1301))+(((-1.31914893617021)*pp)));
evalcond[1]=((-0.713297872340426)+(((-0.2)*x1301))+(((0.64)*x1300))+(((1.06382978723404)*pp)));
evalcond[2]=((((-1.0)*x1303))+((cj2*x1305))+((cj2*x1306)));
evalcond[3]=(x1304+(((-1.0)*x1302))+(((-1.0)*sj2*x1305))+(((-1.0)*sj2*x1306)));
evalcond[4]=(x1305+x1306+(((-1.0)*cj2*x1303))+(((-1.0)*sj2*x1304))+((sj2*x1302)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j1)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x1307=cj2*cj2;
j3eval[0]=cj2;
j3eval[1]=((((1.08680625)*x1307))+(((-2.085)*pp*x1307))+(((2.3716)*(pz*pz)))+((x1307*(pp*pp))));
j3eval[2]=IKsign(cj2);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x1308=(pp*sj2);
IkReal x1309=(cj0*py);
IkReal x1310=(px*sj0);
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
j3eval[2]=((IKabs(((((-3875.0)*x1310))+(((8394.15584415584)*sj2))+(((3875.0)*x1309))+(((-8051.94805194805)*x1308)))))+(IKabs(((((-12400.0)*x1310))+(((-2623.1737012987)*sj2))+(((2516.23376623377)*x1308))+(((12400.0)*x1309))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal j3eval[3];
sj1=-1.0;
cj1=0;
j1=-1.5707963267949;
IkReal x1311=(pp*sj2);
IkReal x1312=(px*sj0);
IkReal x1313=(cj0*py);
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
j3eval[2]=((IKabs(((((125.0)*x1313))+(((-125.0)*x1312))+(((-259.74025974026)*x1311))+(((270.779220779221)*sj2)))))+(IKabs(((((400.0)*x1313))+(((81.1688311688312)*x1311))+(((-84.6185064935065)*sj2))+(((-400.0)*x1312))))));
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  || IKabs(j3eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[2];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((0.96362712021075)+(((-0.924342561353238)*pp))+(((-0.444839857651246)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.301133475065859)+(((-1.42348754448399)*pz))+(((0.288857050422887)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.96362712021075)+(((-0.924342561353238)*pp))+(((-0.444839857651246)*pz))))+IKsqr(((-0.301133475065859)+(((-1.42348754448399)*pz))+(((0.288857050422887)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.96362712021075)+(((-0.924342561353238)*pp))+(((-0.444839857651246)*pz))), ((-0.301133475065859)+(((-1.42348754448399)*pz))+(((0.288857050422887)*pp))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1314=IKcos(j3);
IkReal x1315=IKsin(j3);
evalcond[0]=((((-0.64)*x1314))+(((-0.2)*x1315))+(((-1.0)*pz)));
evalcond[1]=((0.839415584415584)+(((-0.805194805194805)*pp))+(((0.248)*x1314))+(((-0.7936)*x1315)));
evalcond[2]=((-0.676948051948052)+(((0.649350649350649)*pp))+(((-0.2)*x1314))+(((0.64)*x1315)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
if( IKabs(((0.96362712021075)+(((0.444839857651246)*pz))+(((-0.924342561353238)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.301133475065859)+(((0.288857050422887)*pp))+(((1.42348754448399)*pz)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.96362712021075)+(((0.444839857651246)*pz))+(((-0.924342561353238)*pp))))+IKsqr(((-0.301133475065859)+(((0.288857050422887)*pp))+(((1.42348754448399)*pz))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.96362712021075)+(((0.444839857651246)*pz))+(((-0.924342561353238)*pp))), ((-0.301133475065859)+(((0.288857050422887)*pp))+(((1.42348754448399)*pz))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1316=IKcos(j3);
IkReal x1317=IKsin(j3);
evalcond[0]=((((0.2)*x1317))+(((-1.0)*pz))+(((0.64)*x1316)));
evalcond[1]=((0.839415584415584)+(((-0.805194805194805)*pp))+(((0.248)*x1316))+(((-0.7936)*x1317)));
evalcond[2]=((-0.676948051948052)+(((0.649350649350649)*pp))+(((-0.2)*x1316))+(((0.64)*x1317)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1318=(cj0*py);
IkReal x1319=(px*sj0);
if( IKabs(((0.96362712021075)+(((-0.924342561353238)*pp))+(((-0.444839857651246)*x1319))+(((0.444839857651246)*x1318)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.301133475065859)+(((1.42348754448399)*x1318))+(((-1.42348754448399)*x1319))+(((0.288857050422887)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.96362712021075)+(((-0.924342561353238)*pp))+(((-0.444839857651246)*x1319))+(((0.444839857651246)*x1318))))+IKsqr(((-0.301133475065859)+(((1.42348754448399)*x1318))+(((-1.42348754448399)*x1319))+(((0.288857050422887)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.96362712021075)+(((-0.924342561353238)*pp))+(((-0.444839857651246)*x1319))+(((0.444839857651246)*x1318))), ((-0.301133475065859)+(((1.42348754448399)*x1318))+(((-1.42348754448399)*x1319))+(((0.288857050422887)*pp))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1320=IKsin(j3);
IkReal x1321=IKcos(j3);
evalcond[0]=((0.839415584415584)+(((-0.7936)*x1320))+(((-0.805194805194805)*pp))+(((0.248)*x1321)));
evalcond[1]=((-0.676948051948052)+(((0.649350649350649)*pp))+(((-0.2)*x1321))+(((0.64)*x1320)));
evalcond[2]=((((-0.64)*x1321))+(((-0.2)*x1320))+(((-1.0)*px*sj0))+((cj0*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1322=(cj0*py);
IkReal x1323=(px*sj0);
if( IKabs(((0.96362712021075)+(((0.444839857651246)*x1323))+(((-0.924342561353238)*pp))+(((-0.444839857651246)*x1322)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.301133475065859)+(((1.42348754448399)*x1323))+(((-1.42348754448399)*x1322))+(((0.288857050422887)*pp)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.96362712021075)+(((0.444839857651246)*x1323))+(((-0.924342561353238)*pp))+(((-0.444839857651246)*x1322))))+IKsqr(((-0.301133475065859)+(((1.42348754448399)*x1323))+(((-1.42348754448399)*x1322))+(((0.288857050422887)*pp))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.96362712021075)+(((0.444839857651246)*x1323))+(((-0.924342561353238)*pp))+(((-0.444839857651246)*x1322))), ((-0.301133475065859)+(((1.42348754448399)*x1323))+(((-1.42348754448399)*x1322))+(((0.288857050422887)*pp))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1324=IKsin(j3);
IkReal x1325=IKcos(j3);
evalcond[0]=((0.839415584415584)+(((-0.7936)*x1324))+(((-0.805194805194805)*pp))+(((0.248)*x1325)));
evalcond[1]=((-0.676948051948052)+(((0.649350649350649)*pp))+(((-0.2)*x1325))+(((0.64)*x1324)));
evalcond[2]=((((0.2)*x1324))+(((0.64)*x1325))+(((-1.0)*px*sj0))+((cj0*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1326=pp;
IkReal x1327=pp*pp;
IkReal x1328=pz*pz;
IkReal x1329=x1326*x1326;
CheckValue<IkReal> x1332=IKPowWithIntegerCheck(((1.18114782503906)+(((1.08680625)*x1329))+(((1.08680625)*x1327))+(((4.347225)*pp*x1326))+(((-2.085)*pp*x1329))+((x1327*x1329))+(((-2.085)*x1326*x1327))+(((-2.26599103125)*x1326))+(((-2.26599103125)*pp))),-1);
if(!x1332.valid){
continue;
}
IkReal x1330=x1332.value;
IkReal x1331=(x1328*x1330);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((((-2.3716)*x1329*x1331))+(((4.944786)*x1326*x1331))+(((-2.5774697025)*x1331)))))+(IKabs(cj2))+(IKabs(((-1.0)+(IKsign(sj2)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1333=(cj0*py);
IkReal x1334=(px*sj0);
if( IKabs(((0.96362712021075)+(((-0.924342561353238)*pp))+(((-0.444839857651246)*x1334))+(((0.444839857651246)*x1333)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.301133475065859)+(((1.42348754448399)*x1333))+(((0.288857050422887)*pp))+(((-1.42348754448399)*x1334)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.96362712021075)+(((-0.924342561353238)*pp))+(((-0.444839857651246)*x1334))+(((0.444839857651246)*x1333))))+IKsqr(((-0.301133475065859)+(((1.42348754448399)*x1333))+(((0.288857050422887)*pp))+(((-1.42348754448399)*x1334))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.96362712021075)+(((-0.924342561353238)*pp))+(((-0.444839857651246)*x1334))+(((0.444839857651246)*x1333))), ((-0.301133475065859)+(((1.42348754448399)*x1333))+(((0.288857050422887)*pp))+(((-1.42348754448399)*x1334))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1335=IKsin(j3);
IkReal x1336=IKcos(j3);
evalcond[0]=((0.839415584415584)+(((-0.805194805194805)*pp))+(((0.248)*x1336))+(((-0.7936)*x1335)));
evalcond[1]=((-0.676948051948052)+(((0.649350649350649)*pp))+(((0.64)*x1335))+(((-0.2)*x1336)));
evalcond[2]=((((-0.2)*x1335))+(((-0.64)*x1336))+(((-1.0)*px*sj0))+((cj0*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x1337=pp;
IkReal x1338=pp*pp;
IkReal x1339=pz*pz;
IkReal x1340=x1337*x1337;
CheckValue<IkReal> x1343=IKPowWithIntegerCheck(((1.18114782503906)+(((-2.085)*pp*x1340))+(((1.08680625)*x1340))+((x1338*x1340))+(((-2.085)*x1337*x1338))+(((-2.26599103125)*x1337))+(((-2.26599103125)*pp))+(((1.08680625)*x1338))+(((4.347225)*pp*x1337))),-1);
if(!x1343.valid){
continue;
}
IkReal x1341=x1343.value;
IkReal x1342=(x1339*x1341);
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(cj2))+(IKabs(((((-2.5774697025)*x1342))+(((4.944786)*x1337*x1342))+(((-2.3716)*x1340*x1342)))))+(IKabs(((1.0)+(IKsign(sj2)))))), 6.28318530717959)));
evalcond[1]=pz;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1344=(cj0*py);
IkReal x1345=(px*sj0);
if( IKabs(((0.96362712021075)+(((-0.924342561353238)*pp))+(((0.444839857651246)*x1345))+(((-0.444839857651246)*x1344)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-0.301133475065859)+(((-1.42348754448399)*x1344))+(((0.288857050422887)*pp))+(((1.42348754448399)*x1345)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((0.96362712021075)+(((-0.924342561353238)*pp))+(((0.444839857651246)*x1345))+(((-0.444839857651246)*x1344))))+IKsqr(((-0.301133475065859)+(((-1.42348754448399)*x1344))+(((0.288857050422887)*pp))+(((1.42348754448399)*x1345))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((0.96362712021075)+(((-0.924342561353238)*pp))+(((0.444839857651246)*x1345))+(((-0.444839857651246)*x1344))), ((-0.301133475065859)+(((-1.42348754448399)*x1344))+(((0.288857050422887)*pp))+(((1.42348754448399)*x1345))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x1346=IKsin(j3);
IkReal x1347=IKcos(j3);
evalcond[0]=((0.839415584415584)+(((-0.805194805194805)*pp))+(((-0.7936)*x1346))+(((0.248)*x1347)));
evalcond[1]=((-0.676948051948052)+(((-0.2)*x1347))+(((0.649350649350649)*pp))+(((0.64)*x1346)));
evalcond[2]=((((0.2)*x1346))+(((0.64)*x1347))+(((-1.0)*px*sj0))+((cj0*py)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1348=(pp*sj2);
IkReal x1349=(px*sj0);
IkReal x1350=(cj0*py);
CheckValue<IkReal> x1351 = IKatan2WithCheck(IkReal(((((125.0)*x1350))+(((-125.0)*x1349))+(((270.779220779221)*sj2))+(((-259.74025974026)*x1348)))),IkReal(((((400.0)*x1350))+(((-400.0)*x1349))+(((81.1688311688312)*x1348))+(((-84.6185064935065)*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1351.valid){
continue;
}
CheckValue<IkReal> x1352=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x1352.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1351.value)+(((1.5707963267949)*(x1352.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1353=IKsin(j3);
IkReal x1354=IKcos(j3);
IkReal x1355=(px*sj0);
IkReal x1356=(cj0*py);
IkReal x1357=((0.64)*x1354);
IkReal x1358=((0.2)*x1353);
evalcond[0]=((0.839415584415584)+(((-0.805194805194805)*pp))+(((-0.7936)*x1353))+(((0.248)*x1354)));
evalcond[1]=((-0.676948051948052)+(((-0.2)*x1354))+(((0.649350649350649)*pp))+(((0.64)*x1353)));
evalcond[2]=((((-1.0)*cj2*x1357))+(((-1.0)*cj2*x1358))+(((-1.0)*pz)));
evalcond[3]=(x1356+(((-1.0)*x1355))+(((-1.0)*sj2*x1357))+(((-1.0)*sj2*x1358)));
evalcond[4]=(x1358+x1357+(((-1.0)*sj2*x1356))+((cj2*pz))+((sj2*x1355)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1359=(pp*sj2);
IkReal x1360=(cj0*py);
IkReal x1361=(px*sj0);
CheckValue<IkReal> x1362=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x1362.valid){
continue;
}
CheckValue<IkReal> x1363 = IKatan2WithCheck(IkReal(((((-8051.94805194805)*x1359))+(((3875.0)*x1360))+(((8394.15584415584)*sj2))+(((-3875.0)*x1361)))),IkReal(((((2516.23376623377)*x1359))+(((-2623.1737012987)*sj2))+(((-12400.0)*x1361))+(((12400.0)*x1360)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1363.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1362.value)))+(x1363.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1364=IKsin(j3);
IkReal x1365=IKcos(j3);
IkReal x1366=(px*sj0);
IkReal x1367=(cj0*py);
IkReal x1368=((0.64)*x1365);
IkReal x1369=((0.2)*x1364);
evalcond[0]=((0.839415584415584)+(((-0.805194805194805)*pp))+(((-0.7936)*x1364))+(((0.248)*x1365)));
evalcond[1]=((-0.676948051948052)+(((-0.2)*x1365))+(((0.649350649350649)*pp))+(((0.64)*x1364)));
evalcond[2]=((((-1.0)*cj2*x1368))+(((-1.0)*cj2*x1369))+(((-1.0)*pz)));
evalcond[3]=(x1367+(((-1.0)*x1366))+(((-1.0)*sj2*x1368))+(((-1.0)*sj2*x1369)));
evalcond[4]=(x1368+x1369+(((-1.0)*sj2*x1367))+((cj2*pz))+((sj2*x1366)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1370=(cj2*pp);
CheckValue<IkReal> x1371=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x1371.valid){
continue;
}
CheckValue<IkReal> x1372 = IKatan2WithCheck(IkReal(((((-3875.0)*pz))+(((8394.15584415584)*cj2))+(((-8051.94805194805)*x1370)))),IkReal(((((2516.23376623377)*x1370))+(((-2623.1737012987)*cj2))+(((-12400.0)*pz)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1372.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1371.value)))+(x1372.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[5];
IkReal x1373=IKsin(j3);
IkReal x1374=IKcos(j3);
IkReal x1375=(px*sj0);
IkReal x1376=(cj0*py);
IkReal x1377=((0.64)*x1374);
IkReal x1378=((0.2)*x1373);
evalcond[0]=((0.839415584415584)+(((-0.7936)*x1373))+(((-0.805194805194805)*pp))+(((0.248)*x1374)));
evalcond[1]=((-0.676948051948052)+(((0.649350649350649)*pp))+(((-0.2)*x1374))+(((0.64)*x1373)));
evalcond[2]=((((-1.0)*cj2*x1377))+(((-1.0)*cj2*x1378))+(((-1.0)*pz)));
evalcond[3]=(x1376+(((-1.0)*x1375))+(((-1.0)*sj2*x1377))+(((-1.0)*sj2*x1378)));
evalcond[4]=(x1377+x1378+(((-1.0)*sj2*x1376))+((sj2*x1375))+((cj2*pz)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1379=(sj1*sj2);
IkReal x1380=(py*sj0);
IkReal x1381=(cj0*px);
IkReal x1382=(px*sj0);
IkReal x1383=(cj0*py);
IkReal x1384=(cj1*pz*sj2);
CheckValue<IkReal> x1385=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x1385.valid){
continue;
}
CheckValue<IkReal> x1386 = IKatan2WithCheck(IkReal(((((125.0)*x1383))+(((-60.0)*x1379))+(((-400.0)*x1384))+(((400.0)*x1379*x1380))+(((400.0)*x1379*x1381))+(((-125.0)*x1382))+(((248.0)*sj2)))),IkReal(((((125.0)*x1384))+(((-125.0)*x1379*x1381))+(((-125.0)*x1379*x1380))+(((-400.0)*x1382))+(((18.75)*x1379))+(((-77.5)*sj2))+(((400.0)*x1383)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1386.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1385.value)))+(x1386.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x1387=IKcos(j3);
IkReal x1388=IKsin(j3);
IkReal x1389=(px*sj0);
IkReal x1390=(cj0*px);
IkReal x1391=(cj1*cj2);
IkReal x1392=((1.0)*pz);
IkReal x1393=(cj2*sj1);
IkReal x1394=(cj0*py);
IkReal x1395=((0.64)*x1388);
IkReal x1396=((0.64)*x1387);
IkReal x1397=((0.2)*x1387);
IkReal x1398=((1.0)*py*sj0);
IkReal x1399=((0.2)*x1388);
evalcond[0]=(x1394+(((-1.0)*x1389))+(((-1.0)*sj2*x1399))+(((-1.0)*sj2*x1396)));
evalcond[1]=((0.8115)+(((0.3)*x1390))+(((0.248)*x1387))+(((-0.7936)*x1388))+(((-1.0)*pp))+(((0.3)*py*sj0)));
evalcond[2]=((-0.62)+x1395+(((-1.0)*sj1*x1390))+((cj1*pz))+(((-1.0)*sj1*x1398))+(((0.15)*sj1))+(((-1.0)*x1397)));
evalcond[3]=(((x1393*x1399))+((x1393*x1396))+(((0.62)*cj1))+(((-1.0)*cj1*x1395))+(((-1.0)*x1392))+((cj1*x1397)));
evalcond[4]=((0.15)+((sj1*x1395))+(((-0.62)*sj1))+((x1391*x1399))+((x1391*x1396))+(((-1.0)*x1390))+(((-1.0)*sj1*x1397))+(((-1.0)*x1398)));
evalcond[5]=((((0.15)*x1391))+x1399+x1396+(((-1.0)*x1392*x1393))+(((-1.0)*x1391*x1398))+(((-1.0)*x1390*x1391))+(((-1.0)*sj2*x1394))+((sj2*x1389)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1400=(cj1*sj2);
IkReal x1401=(pz*sj2);
IkReal x1402=((5.0)*cj1);
IkReal x1403=(cj0*py);
IkReal x1404=(px*sj0);
IkReal x1405=(cj2*sj1);
IkReal x1406=((16.0)*cj1);
CheckValue<IkReal> x1407 = IKatan2WithCheck(IkReal(((((16.0)*x1403*x1405))+(((9.92)*x1400))+(((-16.0)*x1404*x1405))+(((-1.0)*x1402*x1404))+(((-16.0)*x1401))+((x1402*x1403)))),IkReal(((((-5.0)*x1403*x1405))+(((5.0)*x1404*x1405))+(((-3.1)*x1400))+(((5.0)*x1401))+(((-1.0)*x1404*x1406))+((x1403*x1406)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1407.valid){
continue;
}
CheckValue<IkReal> x1408=IKPowWithIntegerCheck(IKsign(x1400),-1);
if(!x1408.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1407.value)+(((1.5707963267949)*(x1408.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x1409=IKcos(j3);
IkReal x1410=IKsin(j3);
IkReal x1411=(px*sj0);
IkReal x1412=(cj0*px);
IkReal x1413=(cj1*cj2);
IkReal x1414=((1.0)*pz);
IkReal x1415=(cj2*sj1);
IkReal x1416=(cj0*py);
IkReal x1417=((0.64)*x1410);
IkReal x1418=((0.64)*x1409);
IkReal x1419=((0.2)*x1409);
IkReal x1420=((1.0)*py*sj0);
IkReal x1421=((0.2)*x1410);
evalcond[0]=((((-1.0)*sj2*x1421))+(((-1.0)*sj2*x1418))+x1416+(((-1.0)*x1411)));
evalcond[1]=((0.8115)+(((0.3)*x1412))+(((-0.7936)*x1410))+(((-1.0)*pp))+(((0.248)*x1409))+(((0.3)*py*sj0)));
evalcond[2]=((-0.62)+(((-1.0)*x1419))+(((-1.0)*sj1*x1412))+((cj1*pz))+(((-1.0)*sj1*x1420))+x1417+(((0.15)*sj1)));
evalcond[3]=(((x1415*x1418))+((x1415*x1421))+(((-1.0)*x1414))+(((-1.0)*cj1*x1417))+(((0.62)*cj1))+((cj1*x1419)));
evalcond[4]=((0.15)+((x1413*x1418))+(((-0.62)*sj1))+(((-1.0)*sj1*x1419))+((sj1*x1417))+(((-1.0)*x1412))+(((-1.0)*x1420))+((x1413*x1421)));
evalcond[5]=(((sj2*x1411))+(((-1.0)*sj2*x1416))+(((-1.0)*x1414*x1415))+(((0.15)*x1413))+x1421+x1418+(((-1.0)*x1413*x1420))+(((-1.0)*x1412*x1413)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1422=(pp*sj2);
IkReal x1423=((937.5)*sj2);
IkReal x1424=(py*sj0);
IkReal x1425=(cj0*px);
IkReal x1426=((3000.0)*sj2);
IkReal x1427=(px*sj0);
IkReal x1428=(cj0*py);
CheckValue<IkReal> x1429=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x1429.valid){
continue;
}
CheckValue<IkReal> x1430 = IKatan2WithCheck(IkReal(((((8115.0)*sj2))+((x1425*x1426))+((x1424*x1426))+(((-10000.0)*x1422))+(((-3875.0)*x1427))+(((3875.0)*x1428)))),IkReal(((((12400.0)*x1428))+(((3125.0)*x1422))+(((-1.0)*x1423*x1425))+(((-1.0)*x1423*x1424))+(((-12400.0)*x1427))+(((-2535.9375)*sj2)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1430.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1429.value)))+(x1430.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[6];
IkReal x1431=IKcos(j3);
IkReal x1432=IKsin(j3);
IkReal x1433=(px*sj0);
IkReal x1434=(cj0*px);
IkReal x1435=(cj1*cj2);
IkReal x1436=((1.0)*pz);
IkReal x1437=(cj2*sj1);
IkReal x1438=(cj0*py);
IkReal x1439=((0.64)*x1432);
IkReal x1440=((0.64)*x1431);
IkReal x1441=((0.2)*x1431);
IkReal x1442=((1.0)*py*sj0);
IkReal x1443=((0.2)*x1432);
evalcond[0]=((((-1.0)*x1433))+(((-1.0)*sj2*x1440))+(((-1.0)*sj2*x1443))+x1438);
evalcond[1]=((0.8115)+(((-0.7936)*x1432))+(((0.3)*x1434))+(((-1.0)*pp))+(((0.248)*x1431))+(((0.3)*py*sj0)));
evalcond[2]=((-0.62)+(((-1.0)*sj1*x1442))+((cj1*pz))+x1439+(((-1.0)*x1441))+(((-1.0)*sj1*x1434))+(((0.15)*sj1)));
evalcond[3]=(((x1437*x1440))+((x1437*x1443))+((cj1*x1441))+(((-1.0)*cj1*x1439))+(((-1.0)*x1436))+(((0.62)*cj1)));
evalcond[4]=((0.15)+(((-1.0)*x1434))+((x1435*x1443))+((x1435*x1440))+(((-1.0)*sj1*x1441))+(((-0.62)*sj1))+((sj1*x1439))+(((-1.0)*x1442)));
evalcond[5]=((((-1.0)*x1436*x1437))+(((-1.0)*sj2*x1438))+((sj2*x1433))+(((-1.0)*x1434*x1435))+(((-1.0)*x1435*x1442))+x1443+x1440+(((0.15)*x1435)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x1444=(pp*sj2);
IkReal x1445=((937.5)*sj2);
IkReal x1446=(py*sj0);
IkReal x1447=(cj0*px);
IkReal x1448=((3000.0)*sj2);
IkReal x1449=(px*sj0);
IkReal x1450=(cj0*py);
CheckValue<IkReal> x1451 = IKatan2WithCheck(IkReal(((((8115.0)*sj2))+(((3875.0)*x1450))+(((-10000.0)*x1444))+((x1447*x1448))+((x1446*x1448))+(((-3875.0)*x1449)))),IkReal(((((-12400.0)*x1449))+(((-1.0)*x1445*x1447))+(((-1.0)*x1445*x1446))+(((3125.0)*x1444))+(((-2535.9375)*sj2))+(((12400.0)*x1450)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1451.valid){
continue;
}
CheckValue<IkReal> x1452=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x1452.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(x1451.value)+(((1.5707963267949)*(x1452.value))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x1453=IKcos(j3);
IkReal x1454=IKsin(j3);
evalcond[0]=((((-0.2)*sj2*x1454))+(((-0.64)*sj2*x1453))+(((-1.0)*px*sj0))+((cj0*py)));
evalcond[1]=((0.8115)+(((0.3)*cj0*px))+(((-0.7936)*x1454))+(((-1.0)*pp))+(((0.248)*x1453))+(((0.3)*py*sj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j1eval[2];
IkReal x1455=((6.66666666666667)*cj3);
IkReal x1456=(cj0*px);
IkReal x1457=(cj2*pz);
IkReal x1458=(py*sj0);
IkReal x1459=((0.64)*sj3);
IkReal x1460=((21.3333333333333)*sj3);
IkReal x1461=((0.2)*cj3);
j1eval[0]=((3.1)+(((-6.66666666666667)*sj3*x1457))+cj3+(((-20.6666666666667)*x1456))+(((-20.6666666666667)*x1458))+(((-1.0)*x1455*x1458))+(((-1.0)*x1455*x1456))+((x1458*x1460))+(((-3.2)*sj3))+((x1456*x1460))+(((-21.3333333333333)*cj3*x1457)));
j1eval[1]=IKsign(((0.093)+(((-0.096)*sj3))+((x1456*x1459))+(((-1.0)*x1458*x1461))+(((-0.2)*sj3*x1457))+(((-1.0)*x1456*x1461))+(((0.03)*cj3))+((x1458*x1459))+(((-0.62)*x1456))+(((-0.62)*x1458))+(((-0.64)*cj3*x1457))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x1462=(cj3*sj2);
IkReal x1463=(sj2*sj3);
IkReal x1464=(pz*sj2);
IkReal x1465=(cj2*py*sj0);
IkReal x1466=(cj0*cj2*px);
j1eval[0]=(((cj2*x1463))+(((20.6666666666667)*x1464))+(((-21.3333333333333)*pz*x1463))+(((3.2)*cj2*x1462))+(((-21.3333333333333)*x1462*x1465))+(((-21.3333333333333)*x1462*x1466))+(((-6.66666666666667)*x1463*x1466))+(((-6.66666666666667)*x1463*x1465))+(((6.66666666666667)*pz*x1462)));
j1eval[1]=IKsign(((((-0.64)*pz*x1463))+(((0.096)*cj2*x1462))+(((0.62)*x1464))+(((-0.64)*x1462*x1465))+(((-0.64)*x1462*x1466))+(((0.2)*pz*x1462))+(((0.03)*cj2*x1463))+(((-0.2)*x1463*x1466))+(((-0.2)*x1463*x1465))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
IkReal x1467=py*py;
IkReal x1468=cj0*cj0;
IkReal x1469=px*px;
IkReal x1470=pz*pz;
IkReal x1471=((44.4444444444444)*sj2);
IkReal x1472=(py*sj0);
IkReal x1473=((1.0)*sj2);
IkReal x1474=(cj0*px*sj2);
IkReal x1475=(x1467*x1468);
IkReal x1476=(x1468*x1469);
j1eval[0]=(((x1471*x1475))+(((-1.0)*x1471*x1476))+(((-1.0)*x1470*x1471))+(((13.3333333333333)*x1474))+(((-1.0)*x1467*x1471))+(((-1.0)*x1473))+(((13.3333333333333)*sj2*x1472))+(((-88.8888888888889)*x1472*x1474)));
j1eval[1]=IKsign(((((-0.0225)*sj2))+(((-1.0)*x1470*x1473))+(((-2.0)*x1472*x1474))+(((0.3)*sj2*x1472))+(((-1.0)*x1467*x1473))+((sj2*x1475))+(((0.3)*x1474))+(((-1.0)*x1473*x1476))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[2];
sj2=0;
cj2=1.0;
j2=0;
IkReal x1477=(pz*sj3);
IkReal x1478=((0.64)*cj3);
IkReal x1479=(cj0*px);
IkReal x1480=(py*sj0);
IkReal x1481=((0.2)*sj3);
IkReal x1482=((21.3333333333333)*cj3);
IkReal x1483=((6.66666666666667)*sj3);
IkReal x1484=(cj3*pz);
j1eval[0]=(sj3+(((-1.0)*x1479*x1482))+(((-1.0)*x1479*x1483))+(((-1.0)*x1480*x1483))+(((-1.0)*x1480*x1482))+(((-21.3333333333333)*x1477))+(((3.2)*cj3))+(((20.6666666666667)*pz))+(((6.66666666666667)*x1484)));
j1eval[1]=IKsign(((((-1.0)*x1478*x1479))+(((-1.0)*x1479*x1481))+(((0.03)*sj3))+(((-1.0)*x1480*x1481))+(((-0.64)*x1477))+(((0.62)*pz))+(((0.096)*cj3))+(((0.2)*x1484))+(((-1.0)*x1478*x1480))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[3];
sj2=0;
cj2=1.0;
j2=0;
IkReal x1485=cj3*cj3;
IkReal x1486=(py*sj0);
IkReal x1487=(cj0*px);
IkReal x1488=(pz*sj3);
IkReal x1489=((0.2)*cj3);
IkReal x1490=(cj3*pz);
IkReal x1491=((21.3333333333333)*sj3);
IkReal x1492=(cj3*sj3);
IkReal x1493=((0.64)*sj3);
IkReal x1494=((6.66666666666667)*cj3);
j1eval[0]=((-3.1)+(((-1.0)*x1487*x1491))+(((3.2)*sj3))+(((-1.0)*x1486*x1491))+((x1487*x1494))+(((21.3333333333333)*x1490))+((x1486*x1494))+(((20.6666666666667)*x1486))+(((20.6666666666667)*x1487))+(((6.66666666666667)*x1488))+(((-1.0)*cj3)));
j1eval[1]=((IKabs(((-0.128)+(((0.256)*x1485))+((pz*x1486))+((pz*x1487))+(((-0.3696)*x1492))+(((0.3968)*cj3))+(((-0.15)*pz))+(((0.124)*sj3)))))+(IKabs(((-0.794)+(((0.256)*x1492))+(((-0.248)*cj3))+(((0.7936)*sj3))+(((0.3696)*x1485))+(pz*pz)))));
j1eval[2]=IKsign(((-0.093)+(((-1.0)*x1487*x1493))+(((-1.0)*x1486*x1493))+((x1487*x1489))+(((0.62)*x1487))+(((0.62)*x1486))+((x1486*x1489))+(((0.096)*sj3))+(((0.64)*x1490))+(((0.2)*x1488))+(((-0.03)*cj3))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=1.0;
j2=0;
IkReal x1495=cj0*cj0;
IkReal x1496=py*py;
IkReal x1497=pz*pz;
IkReal x1498=px*px;
IkReal x1499=(cj0*px);
IkReal x1500=(py*sj0);
IkReal x1501=(x1495*x1496);
IkReal x1502=(x1495*x1498);
j1eval[0]=((1.0)+(((44.4444444444444)*x1502))+(((44.4444444444444)*x1496))+(((44.4444444444444)*x1497))+(((-44.4444444444444)*x1501))+(((-13.3333333333333)*x1500))+(((88.8888888888889)*x1499*x1500))+(((-13.3333333333333)*x1499)));
j1eval[1]=IKsign(((0.0225)+(((-1.0)*x1501))+x1502+x1496+x1497+(((-0.3)*x1499))+(((-0.3)*x1500))+(((2.0)*x1499*x1500))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1503=cj0*cj0;
IkReal x1504=py*py;
IkReal x1505=(py*sj0);
IkReal x1506=((0.2)*sj3);
IkReal x1507=(cj0*px);
IkReal x1508=(cj3*pz);
IkReal x1509=((0.2)*cj3);
IkReal x1510=((0.64)*cj3);
IkReal x1511=((0.64)*sj3);
CheckValue<IkReal> x1512=IKPowWithIntegerCheck(IKsign(((0.0225)+(((-1.0)*x1503*x1504))+((x1503*(px*px)))+(((2.0)*x1505*x1507))+(pz*pz)+x1504+(((-0.3)*x1505))+(((-0.3)*x1507)))),-1);
if(!x1512.valid){
continue;
}
CheckValue<IkReal> x1513 = IKatan2WithCheck(IkReal(((0.093)+(((-0.096)*sj3))+(((-1.0)*x1507*x1509))+(((0.64)*x1508))+((x1507*x1511))+(((0.03)*cj3))+((pz*x1506))+((x1505*x1511))+(((-0.62)*x1505))+(((-0.62)*x1507))+(((-1.0)*x1505*x1509)))),IkReal(((((-0.03)*sj3))+((x1507*x1510))+(((-0.096)*cj3))+((x1506*x1507))+(((0.62)*pz))+(((0.2)*x1508))+(((-1.0)*pz*x1511))+((x1505*x1510))+((x1505*x1506)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1513.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1512.value)))+(x1513.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1514=IKsin(j1);
IkReal x1515=IKcos(j1);
IkReal x1516=((0.2)*cj3);
IkReal x1517=(cj0*px);
IkReal x1518=((0.64)*sj3);
IkReal x1519=((0.2)*sj3);
IkReal x1520=((0.64)*cj3);
IkReal x1521=(py*sj0);
IkReal x1522=((1.0)*x1514);
IkReal x1523=((1.0)*x1515);
IkReal x1524=(pz*x1515);
IkReal x1525=((1.24)*x1514);
evalcond[0]=((-0.62)+(((-1.0)*x1516))+x1524+x1518+(((0.15)*x1514))+(((-1.0)*x1517*x1522))+(((-1.0)*x1521*x1522)));
evalcond[1]=(x1520+x1519+(((0.15)*x1515))+(((-1.0)*x1517*x1523))+(((-1.0)*pz*x1522))+(((-1.0)*x1521*x1523)));
evalcond[2]=((((-1.0)*x1515*x1518))+((x1514*x1519))+(((-1.0)*pz))+((x1515*x1516))+(((0.62)*x1515))+((x1514*x1520)));
evalcond[3]=((0.0427)+(((1.24)*x1524))+(((-1.0)*pp))+(((0.186)*x1514))+(((0.3)*x1517))+(((-1.0)*x1517*x1525))+(((0.3)*x1521))+(((-1.0)*x1521*x1525)));
evalcond[4]=((0.15)+((x1514*x1518))+(((-1.0)*x1517))+(((-1.0)*x1514*x1516))+((x1515*x1519))+((x1515*x1520))+(((-0.62)*x1514))+(((-1.0)*x1521)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1526=cj3*cj3;
IkReal x1527=(cj0*px);
IkReal x1528=((0.2)*cj3);
IkReal x1529=(py*sj0);
IkReal x1530=(cj3*sj3);
IkReal x1531=((0.64)*sj3);
CheckValue<IkReal> x1532 = IKatan2WithCheck(IkReal(((-0.794)+(((-0.248)*cj3))+(((0.7936)*sj3))+(((0.3696)*x1526))+(pz*pz)+(((0.256)*x1530)))),IkReal(((-0.128)+(((-0.3696)*x1530))+(((0.3968)*cj3))+(((-0.15)*pz))+(((0.124)*sj3))+((pz*x1529))+((pz*x1527))+(((0.256)*x1526)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1532.valid){
continue;
}
CheckValue<IkReal> x1533=IKPowWithIntegerCheck(IKsign(((-0.093)+(((-1.0)*x1529*x1531))+(((0.2)*pz*sj3))+(((0.64)*cj3*pz))+((x1528*x1529))+(((0.096)*sj3))+((x1527*x1528))+(((-1.0)*x1527*x1531))+(((0.62)*x1529))+(((0.62)*x1527))+(((-0.03)*cj3)))),-1);
if(!x1533.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1532.value)+(((1.5707963267949)*(x1533.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1534=IKsin(j1);
IkReal x1535=IKcos(j1);
IkReal x1536=((0.2)*cj3);
IkReal x1537=(cj0*px);
IkReal x1538=((0.64)*sj3);
IkReal x1539=((0.2)*sj3);
IkReal x1540=((0.64)*cj3);
IkReal x1541=(py*sj0);
IkReal x1542=((1.0)*x1534);
IkReal x1543=((1.0)*x1535);
IkReal x1544=(pz*x1535);
IkReal x1545=((1.24)*x1534);
evalcond[0]=((-0.62)+(((-1.0)*x1536))+(((0.15)*x1534))+x1544+x1538+(((-1.0)*x1537*x1542))+(((-1.0)*x1541*x1542)));
evalcond[1]=((((-1.0)*pz*x1542))+(((0.15)*x1535))+x1540+x1539+(((-1.0)*x1537*x1543))+(((-1.0)*x1541*x1543)));
evalcond[2]=(((x1534*x1540))+(((-1.0)*pz))+(((-1.0)*x1535*x1538))+((x1535*x1536))+((x1534*x1539))+(((0.62)*x1535)));
evalcond[3]=((0.0427)+(((1.24)*x1544))+(((-1.0)*pp))+(((-1.0)*x1537*x1545))+(((0.3)*x1541))+(((0.186)*x1534))+(((-1.0)*x1541*x1545))+(((0.3)*x1537)));
evalcond[4]=((0.15)+(((-1.0)*x1541))+(((-1.0)*x1537))+((x1535*x1539))+(((-0.62)*x1534))+(((-1.0)*x1534*x1536))+((x1535*x1540))+((x1534*x1538)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1546=cj3*cj3;
IkReal x1547=(py*sj0);
IkReal x1548=((0.2)*sj3);
IkReal x1549=((0.64)*cj3);
IkReal x1550=((1.0)*pz);
IkReal x1551=(cj3*sj3);
IkReal x1552=(cj0*px);
CheckValue<IkReal> x1553=IKPowWithIntegerCheck(IKsign(((((0.2)*cj3*pz))+(((0.03)*sj3))+(((-1.0)*x1549*x1552))+(((-0.64)*pz*sj3))+(((-1.0)*x1548*x1552))+(((-1.0)*x1547*x1549))+(((-1.0)*x1547*x1548))+(((0.62)*pz))+(((0.096)*cj3)))),-1);
if(!x1553.valid){
continue;
}
CheckValue<IkReal> x1554 = IKatan2WithCheck(IkReal(((-0.128)+(((0.15)*pz))+(((0.3968)*cj3))+(((0.124)*sj3))+(((0.256)*x1546))+(((-0.3696)*x1551))+(((-1.0)*x1550*x1552))+(((-1.0)*x1547*x1550)))),IkReal(((-0.04)+(((-0.256)*x1551))+(pz*pz)+(((-0.3696)*x1546)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1554.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1553.value)))+(x1554.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1555=IKsin(j1);
IkReal x1556=IKcos(j1);
IkReal x1557=((0.2)*cj3);
IkReal x1558=(cj0*px);
IkReal x1559=((0.64)*sj3);
IkReal x1560=((0.2)*sj3);
IkReal x1561=((0.64)*cj3);
IkReal x1562=(py*sj0);
IkReal x1563=((1.0)*x1555);
IkReal x1564=((1.0)*x1556);
IkReal x1565=(pz*x1556);
IkReal x1566=((1.24)*x1555);
evalcond[0]=((-0.62)+(((-1.0)*x1562*x1563))+(((0.15)*x1555))+x1565+x1559+(((-1.0)*x1557))+(((-1.0)*x1558*x1563)));
evalcond[1]=((((-1.0)*pz*x1563))+(((-1.0)*x1562*x1564))+(((0.15)*x1556))+x1560+x1561+(((-1.0)*x1558*x1564)));
evalcond[2]=(((x1555*x1560))+((x1555*x1561))+((x1556*x1557))+(((-1.0)*pz))+(((0.62)*x1556))+(((-1.0)*x1556*x1559)));
evalcond[3]=((0.0427)+(((-1.0)*x1562*x1566))+(((1.24)*x1565))+(((-1.0)*pp))+(((0.186)*x1555))+(((0.3)*x1558))+(((0.3)*x1562))+(((-1.0)*x1558*x1566)));
evalcond[4]=((0.15)+(((-1.0)*x1558))+((x1556*x1561))+((x1556*x1560))+((x1555*x1559))+(((-1.0)*x1555*x1557))+(((-1.0)*x1562))+(((-0.62)*x1555)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j1eval[3];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x1567=cj3*cj3;
IkReal x1568=(py*sj0);
IkReal x1569=((0.2)*sj3);
IkReal x1570=((21.3333333333333)*cj3);
IkReal x1571=((6.66666666666667)*sj3);
IkReal x1572=(cj3*pz);
IkReal x1573=(cj3*sj3);
IkReal x1574=(cj0*px);
IkReal x1575=((0.64)*cj3);
IkReal x1576=(pz*sj3);
j1eval[0]=((((-6.66666666666667)*x1572))+(((-1.0)*x1571*x1574))+sj3+(((-1.0)*x1570*x1574))+(((-1.0)*x1568*x1571))+(((-1.0)*x1568*x1570))+(((-20.6666666666667)*pz))+(((3.2)*cj3))+(((21.3333333333333)*x1576)));
j1eval[1]=IKsign(((((0.03)*sj3))+(((0.64)*x1576))+(((-0.62)*pz))+(((-1.0)*x1568*x1569))+(((-1.0)*x1568*x1575))+(((-1.0)*x1574*x1575))+(((-1.0)*x1569*x1574))+(((0.096)*cj3))+(((-0.2)*x1572))));
j1eval[2]=((IKabs(((0.04)+(((0.256)*x1573))+(((-1.0)*(pz*pz)))+(((0.3696)*x1567)))))+(IKabs(((-0.128)+(((0.3968)*cj3))+(((-0.15)*pz))+(((0.124)*sj3))+(((-0.3696)*x1573))+(((0.256)*x1567))+((pz*x1568))+((pz*x1574))))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  || IKabs(j1eval[2]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x1577=(cj0*px);
IkReal x1578=(pz*sj3);
IkReal x1579=(py*sj0);
IkReal x1580=((0.64)*sj3);
IkReal x1581=((6.66666666666667)*cj3);
IkReal x1582=((21.3333333333333)*sj3);
IkReal x1583=((0.2)*cj3);
IkReal x1584=(cj3*pz);
j1eval[0]=((3.1)+cj3+(((6.66666666666667)*x1578))+(((-20.6666666666667)*x1579))+(((-20.6666666666667)*x1577))+(((-1.0)*x1577*x1581))+(((-3.2)*sj3))+(((-1.0)*x1579*x1581))+((x1577*x1582))+((x1579*x1582))+(((21.3333333333333)*x1584)));
j1eval[1]=IKsign(((0.093)+(((-0.096)*sj3))+(((-1.0)*x1577*x1583))+(((0.64)*x1584))+(((0.03)*cj3))+(((-1.0)*x1579*x1583))+((x1577*x1580))+((x1579*x1580))+(((0.2)*x1578))+(((-0.62)*x1579))+(((-0.62)*x1577))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
{
IkReal j1eval[2];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
IkReal x1585=py*py;
IkReal x1586=cj0*cj0;
IkReal x1587=px*px;
IkReal x1588=pz*pz;
IkReal x1589=(cj0*px);
IkReal x1590=(py*sj0);
IkReal x1591=(x1585*x1586);
IkReal x1592=(x1586*x1587);
j1eval[0]=((-1.0)+(((13.3333333333333)*x1589))+(((13.3333333333333)*x1590))+(((-88.8888888888889)*x1589*x1590))+(((44.4444444444444)*x1591))+(((-44.4444444444444)*x1585))+(((-44.4444444444444)*x1588))+(((-44.4444444444444)*x1592)));
j1eval[1]=IKsign(((-0.0225)+(((-2.0)*x1589*x1590))+x1591+(((0.3)*x1589))+(((-1.0)*x1585))+(((-1.0)*x1588))+(((0.3)*x1590))+(((-1.0)*x1592))));
if( IKabs(j1eval[0]) < 0.0000010000000000  || IKabs(j1eval[1]) < 0.0000010000000000  )
{
continue; // no branches [j1]

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1593=py*py;
IkReal x1594=cj0*cj0;
IkReal x1595=(cj0*px);
IkReal x1596=(cj3*pz);
IkReal x1597=(pz*sj3);
IkReal x1598=(py*sj0);
IkReal x1599=((0.64)*cj3);
IkReal x1600=((0.64)*sj3);
IkReal x1601=((0.2)*x1598);
CheckValue<IkReal> x1602 = IKatan2WithCheck(IkReal(((-0.093)+(((0.64)*x1596))+(((-1.0)*x1595*x1600))+((cj3*x1601))+(((0.2)*cj3*x1595))+(((0.096)*sj3))+(((0.62)*x1598))+(((0.62)*x1595))+(((-0.03)*cj3))+(((0.2)*x1597))+(((-1.0)*x1598*x1600)))),IkReal(((((-0.03)*sj3))+((sj3*x1601))+(((-0.62)*pz))+(((0.64)*x1597))+(((-0.096)*cj3))+((x1598*x1599))+(((0.2)*sj3*x1595))+((x1595*x1599))+(((-0.2)*x1596)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1602.valid){
continue;
}
CheckValue<IkReal> x1603=IKPowWithIntegerCheck(IKsign(((-0.0225)+((x1593*x1594))+(((-2.0)*x1595*x1598))+(((-1.0)*(pz*pz)))+(((0.3)*x1598))+(((0.3)*x1595))+(((-1.0)*x1594*(px*px)))+(((-1.0)*x1593)))),-1);
if(!x1603.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1602.value)+(((1.5707963267949)*(x1603.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1604=IKcos(j1);
IkReal x1605=IKsin(j1);
IkReal x1606=((0.2)*cj3);
IkReal x1607=(cj0*px);
IkReal x1608=((0.64)*sj3);
IkReal x1609=((0.2)*sj3);
IkReal x1610=((0.64)*cj3);
IkReal x1611=(py*sj0);
IkReal x1612=((1.0)*x1605);
IkReal x1613=(pz*x1604);
IkReal x1614=((1.24)*x1605);
evalcond[0]=(x1610+x1609+(((-0.15)*x1604))+((x1604*x1611))+((x1604*x1607))+((pz*x1605)));
evalcond[1]=((-0.62)+(((-1.0)*x1611*x1612))+(((-1.0)*x1606))+x1613+x1608+(((0.15)*x1605))+(((-1.0)*x1607*x1612)));
evalcond[2]=((((-1.0)*pz))+(((-1.0)*x1605*x1609))+(((-1.0)*x1605*x1610))+((x1604*x1606))+(((0.62)*x1604))+(((-1.0)*x1604*x1608)));
evalcond[3]=((0.0427)+(((0.3)*x1611))+(((-1.0)*x1611*x1614))+(((1.24)*x1613))+(((-1.0)*pp))+(((0.186)*x1605))+(((-1.0)*x1607*x1614))+(((0.3)*x1607)));
evalcond[4]=((0.15)+(((-0.62)*x1605))+(((-1.0)*x1611))+(((-1.0)*x1607))+(((-1.0)*x1605*x1606))+((x1605*x1608))+(((-1.0)*x1604*x1610))+(((-1.0)*x1604*x1609)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1615=cj3*cj3;
IkReal x1616=((0.2)*cj3);
IkReal x1617=(cj0*px);
IkReal x1618=(py*sj0);
IkReal x1619=(cj3*sj3);
IkReal x1620=((0.64)*sj3);
IkReal x1621=((1.0)*pz);
CheckValue<IkReal> x1622=IKPowWithIntegerCheck(IKsign(((0.093)+(((0.2)*pz*sj3))+(((-0.096)*sj3))+(((0.64)*cj3*pz))+(((-1.0)*x1616*x1617))+(((-1.0)*x1616*x1618))+((x1617*x1620))+(((0.03)*cj3))+((x1618*x1620))+(((-0.62)*x1617))+(((-0.62)*x1618)))),-1);
if(!x1622.valid){
continue;
}
CheckValue<IkReal> x1623 = IKatan2WithCheck(IkReal(((0.794)+(((-0.3696)*x1615))+(((-1.0)*pz*x1621))+(((-0.256)*x1619))+(((-0.7936)*sj3))+(((0.248)*cj3)))),IkReal(((-0.128)+(((0.15)*pz))+(((-0.3696)*x1619))+(((0.3968)*cj3))+(((-1.0)*x1617*x1621))+(((0.124)*sj3))+(((0.256)*x1615))+(((-1.0)*x1618*x1621)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1623.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1622.value)))+(x1623.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1624=IKcos(j1);
IkReal x1625=IKsin(j1);
IkReal x1626=((0.2)*cj3);
IkReal x1627=(cj0*px);
IkReal x1628=((0.64)*sj3);
IkReal x1629=((0.2)*sj3);
IkReal x1630=((0.64)*cj3);
IkReal x1631=(py*sj0);
IkReal x1632=((1.0)*x1625);
IkReal x1633=(pz*x1624);
IkReal x1634=((1.24)*x1625);
evalcond[0]=(((pz*x1625))+x1629+x1630+(((-0.15)*x1624))+((x1624*x1631))+((x1624*x1627)));
evalcond[1]=((-0.62)+(((0.15)*x1625))+x1628+x1633+(((-1.0)*x1626))+(((-1.0)*x1631*x1632))+(((-1.0)*x1627*x1632)));
evalcond[2]=((((0.62)*x1624))+(((-1.0)*x1625*x1630))+(((-1.0)*pz))+(((-1.0)*x1625*x1629))+(((-1.0)*x1624*x1628))+((x1624*x1626)));
evalcond[3]=((0.0427)+(((0.3)*x1627))+(((0.3)*x1631))+(((1.24)*x1633))+(((-1.0)*pp))+(((0.186)*x1625))+(((-1.0)*x1631*x1634))+(((-1.0)*x1627*x1634)));
evalcond[4]=((0.15)+(((-1.0)*x1627))+(((-1.0)*x1624*x1630))+(((-1.0)*x1631))+(((-1.0)*x1625*x1626))+(((-1.0)*x1624*x1629))+(((-0.62)*x1625))+((x1625*x1628)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1635=cj3*cj3;
IkReal x1636=(py*sj0);
IkReal x1637=((0.2)*sj3);
IkReal x1638=((0.64)*cj3);
IkReal x1639=(cj3*sj3);
IkReal x1640=(cj0*px);
CheckValue<IkReal> x1641 = IKatan2WithCheck(IkReal(((-0.128)+(((-0.3696)*x1639))+((pz*x1640))+((pz*x1636))+(((0.3968)*cj3))+(((-0.15)*pz))+(((0.124)*sj3))+(((0.256)*x1635)))),IkReal(((0.04)+(((0.3696)*x1635))+(((-1.0)*(pz*pz)))+(((0.256)*x1639)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1641.valid){
continue;
}
CheckValue<IkReal> x1642=IKPowWithIntegerCheck(IKsign(((((0.03)*sj3))+(((-0.62)*pz))+(((-1.0)*x1638*x1640))+(((0.64)*pz*sj3))+(((-1.0)*x1637*x1640))+(((-1.0)*x1636*x1637))+(((-1.0)*x1636*x1638))+(((0.096)*cj3))+(((-0.2)*cj3*pz)))),-1);
if(!x1642.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1641.value)+(((1.5707963267949)*(x1642.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[5];
IkReal x1643=IKcos(j1);
IkReal x1644=IKsin(j1);
IkReal x1645=((0.2)*cj3);
IkReal x1646=(cj0*px);
IkReal x1647=((0.64)*sj3);
IkReal x1648=((0.2)*sj3);
IkReal x1649=((0.64)*cj3);
IkReal x1650=(py*sj0);
IkReal x1651=((1.0)*x1644);
IkReal x1652=(pz*x1643);
IkReal x1653=((1.24)*x1644);
evalcond[0]=((((-0.15)*x1643))+((pz*x1644))+x1649+x1648+((x1643*x1650))+((x1643*x1646)));
evalcond[1]=((-0.62)+x1652+x1647+(((-1.0)*x1646*x1651))+(((-1.0)*x1650*x1651))+(((-1.0)*x1645))+(((0.15)*x1644)));
evalcond[2]=((((-1.0)*x1644*x1649))+(((-1.0)*x1644*x1648))+(((0.62)*x1643))+(((-1.0)*pz))+(((-1.0)*x1643*x1647))+((x1643*x1645)));
evalcond[3]=((0.0427)+(((0.3)*x1646))+(((-1.0)*x1646*x1653))+(((0.3)*x1650))+(((-1.0)*x1650*x1653))+(((-1.0)*pp))+(((0.186)*x1644))+(((1.24)*x1652)));
evalcond[4]=((0.15)+(((-1.0)*x1644*x1645))+(((-1.0)*x1650))+(((-1.0)*x1646))+((x1644*x1647))+(((-1.0)*x1643*x1649))+(((-1.0)*x1643*x1648))+(((-0.62)*x1644)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j1]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1654=py*py;
IkReal x1655=cj0*cj0;
IkReal x1656=px*px;
IkReal x1657=(cj2*py);
IkReal x1658=((1.0)*cj0);
IkReal x1659=(sj2*sj3);
IkReal x1660=(cj0*px);
IkReal x1661=((1.0)*sj2);
IkReal x1662=(pz*sj2);
IkReal x1663=(cj2*sj0);
IkReal x1664=((0.2)*cj3);
IkReal x1665=(py*sj0*sj2);
CheckValue<IkReal> x1666 = IKatan2WithCheck(IkReal(((((-0.093)*sj2))+(((0.096)*x1659))+(((-1.0)*pz*x1657*x1658))+(((-0.64)*py*sj0*x1659))+((sj2*x1660*x1664))+(((0.62)*sj2*x1660))+(((-0.03)*cj3*sj2))+(((0.62)*x1665))+(((-0.64)*x1659*x1660))+((x1664*x1665))+((px*pz*x1663)))),IkReal(((((-1.0)*x1662*x1664))+((px*x1657))+(((-1.0)*x1654*x1658*x1663))+(((-2.0)*px*x1655*x1657))+(((-0.62)*x1662))+(((0.64)*pz*x1659))+(((0.15)*cj0*x1657))+((cj0*x1656*x1663))+(((-0.15)*px*x1663)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1666.valid){
continue;
}
CheckValue<IkReal> x1667=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1661*(pz*pz)))+(((-0.0225)*sj2))+(((-1.0)*x1655*x1656*x1661))+(((-1.0)*x1654*x1661))+(((0.3)*x1665))+(((0.3)*sj2*x1660))+((sj2*x1654*x1655))+(((-2.0)*x1660*x1665)))),-1);
if(!x1667.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(x1666.value)+(((1.5707963267949)*(x1667.value))));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1668=IKsin(j1);
IkReal x1669=IKcos(j1);
IkReal x1670=((0.2)*cj3);
IkReal x1671=(px*sj2);
IkReal x1672=(cj0*px);
IkReal x1673=((0.64)*sj3);
IkReal x1674=((1.0)*py);
IkReal x1675=((0.64)*cj3);
IkReal x1676=(cj2*px);
IkReal x1677=(py*sj0);
IkReal x1678=((0.2)*sj3);
IkReal x1679=(cj0*x1669);
IkReal x1680=((1.0)*x1668);
IkReal x1681=(cj2*x1669);
IkReal x1682=(cj2*x1668);
IkReal x1683=(pz*x1669);
IkReal x1684=(sj2*x1669);
IkReal x1685=((1.24)*x1668);
evalcond[0]=((-0.62)+x1673+x1683+(((-1.0)*x1672*x1680))+(((0.15)*x1668))+(((-1.0)*sj0*x1668*x1674))+(((-1.0)*x1670)));
evalcond[1]=((((-1.0)*x1669*x1673))+((x1675*x1682))+(((0.62)*x1669))+((x1669*x1670))+(((-1.0)*pz))+((x1678*x1682)));
evalcond[2]=(((sj0*x1676))+((pz*sj2*x1668))+((x1677*x1684))+(((-0.15)*x1684))+(((-1.0)*cj0*cj2*x1674))+((x1671*x1679)));
evalcond[3]=((0.0427)+(((0.186)*x1668))+(((-1.0)*x1677*x1685))+(((1.24)*x1683))+(((-1.0)*x1672*x1685))+(((0.3)*x1672))+(((0.3)*x1677))+(((-1.0)*pp)));
evalcond[4]=((0.15)+(((-1.0)*x1668*x1670))+((x1675*x1681))+((x1668*x1673))+(((-1.0)*sj0*x1674))+(((-1.0)*x1672))+(((-0.62)*x1668))+((x1678*x1681)));
evalcond[5]=(((sj0*x1671))+x1678+x1675+(((0.15)*x1681))+(((-1.0)*cj0*sj2*x1674))+(((-1.0)*cj2*pz*x1680))+(((-1.0)*sj0*x1674*x1681))+(((-1.0)*x1672*x1681)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1686=cj2*cj2;
IkReal x1687=(pz*sj2);
IkReal x1688=(cj2*sj2);
IkReal x1689=(cj0*px);
IkReal x1690=((0.64)*cj3);
IkReal x1691=((0.2)*cj3);
IkReal x1692=((0.64)*sj3);
IkReal x1693=(cj0*py);
IkReal x1694=((0.2)*sj3);
IkReal x1695=(py*sj0);
IkReal x1696=(sj0*x1694);
IkReal x1697=(px*x1686);
IkReal x1698=(cj2*px*sj0);
CheckValue<IkReal> x1699=IKPowWithIntegerCheck(IKsign(((((-1.0)*x1688*x1694*x1695))+(((-1.0)*x1687*x1692))+(((-1.0)*x1688*x1690*x1695))+(((-1.0)*x1688*x1689*x1690))+(((-1.0)*x1688*x1689*x1694))+(((0.62)*x1687))+(((0.096)*cj3*x1688))+(((0.03)*sj3*x1688))+((x1687*x1691)))),-1);
if(!x1699.valid){
continue;
}
CheckValue<IkReal> x1700 = IKatan2WithCheck(IkReal(((((-0.62)*x1698))+(((0.62)*cj2*x1693))+(((0.15)*x1687))+(((-1.0)*x1687*x1689))+((x1692*x1698))+(((-1.0)*x1691*x1698))+((cj2*x1691*x1693))+(((-1.0)*x1687*x1695))+(((-1.0)*cj2*x1692*x1693)))),IkReal((((sj0*x1690*x1697))+(((-1.0)*x1686*x1693*x1694))+((pz*x1687))+((x1696*x1697))+(((-1.0)*x1686*x1690*x1693)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1700.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1699.value)))+(x1700.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1701=IKsin(j1);
IkReal x1702=IKcos(j1);
IkReal x1703=((0.2)*cj3);
IkReal x1704=(px*sj2);
IkReal x1705=(cj0*px);
IkReal x1706=((0.64)*sj3);
IkReal x1707=((1.0)*py);
IkReal x1708=((0.64)*cj3);
IkReal x1709=(cj2*px);
IkReal x1710=(py*sj0);
IkReal x1711=((0.2)*sj3);
IkReal x1712=(cj0*x1702);
IkReal x1713=((1.0)*x1701);
IkReal x1714=(cj2*x1702);
IkReal x1715=(cj2*x1701);
IkReal x1716=(pz*x1702);
IkReal x1717=(sj2*x1702);
IkReal x1718=((1.24)*x1701);
evalcond[0]=((-0.62)+x1706+x1716+(((-1.0)*x1703))+(((0.15)*x1701))+(((-1.0)*x1705*x1713))+(((-1.0)*sj0*x1701*x1707)));
evalcond[1]=((((-1.0)*x1702*x1706))+(((-1.0)*pz))+((x1711*x1715))+(((0.62)*x1702))+((x1702*x1703))+((x1708*x1715)));
evalcond[2]=(((x1710*x1717))+(((-1.0)*cj0*cj2*x1707))+(((-0.15)*x1717))+((x1704*x1712))+((sj0*x1709))+((pz*sj2*x1701)));
evalcond[3]=((0.0427)+(((-1.0)*x1710*x1718))+(((1.24)*x1716))+(((0.3)*x1710))+(((0.3)*x1705))+(((-1.0)*pp))+(((0.186)*x1701))+(((-1.0)*x1705*x1718)));
evalcond[4]=((0.15)+(((-1.0)*x1705))+(((-1.0)*sj0*x1707))+((x1701*x1706))+((x1711*x1714))+(((-0.62)*x1701))+((x1708*x1714))+(((-1.0)*x1701*x1703)));
evalcond[5]=((((-1.0)*cj0*sj2*x1707))+(((-1.0)*sj0*x1707*x1714))+x1708+x1711+(((-1.0)*cj2*pz*x1713))+(((-1.0)*x1705*x1714))+(((0.15)*x1714))+((sj0*x1704)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}

} else
{
{
IkReal j1array[1], cj1array[1], sj1array[1];
bool j1valid[1]={false};
_nj1 = 1;
IkReal x1719=cj3*cj3;
IkReal x1720=(cj2*sj3);
IkReal x1721=(cj0*px);
IkReal x1722=((0.2)*cj3);
IkReal x1723=(py*sj0);
IkReal x1724=(cj2*cj3);
IkReal x1725=((0.64)*sj3);
IkReal x1726=((1.0)*pz);
CheckValue<IkReal> x1727=IKPowWithIntegerCheck(IKsign(((0.093)+(((-0.096)*sj3))+((x1723*x1725))+(((-1.0)*x1722*x1723))+((x1721*x1725))+(((-0.62)*x1721))+(((-0.62)*x1723))+(((0.03)*cj3))+(((-0.2)*pz*x1720))+(((-1.0)*x1721*x1722))+(((-0.64)*pz*x1724)))),-1);
if(!x1727.valid){
continue;
}
CheckValue<IkReal> x1728 = IKatan2WithCheck(IkReal(((0.794)+(((-1.0)*pz*x1726))+(((-0.3696)*x1719))+(((-0.256)*cj3*sj3))+(((-0.7936)*sj3))+(((0.248)*cj3)))),IkReal(((((0.3696)*cj3*x1720))+(((0.15)*pz))+(((-0.124)*x1720))+(((-0.3968)*x1724))+(((-0.256)*cj2*x1719))+(((-1.0)*x1723*x1726))+(((0.128)*cj2))+(((-1.0)*x1721*x1726)))),IKFAST_ATAN2_MAGTHRESH);
if(!x1728.valid){
continue;
}
j1array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1727.value)))+(x1728.value));
sj1array[0]=IKsin(j1array[0]);
cj1array[0]=IKcos(j1array[0]);
if( j1array[0] > IKPI )
{
    j1array[0]-=IK2PI;
}
else if( j1array[0] < -IKPI )
{    j1array[0]+=IK2PI;
}
j1valid[0] = true;
for(int ij1 = 0; ij1 < 1; ++ij1)
{
if( !j1valid[ij1] )
{
    continue;
}
_ij1[0] = ij1; _ij1[1] = -1;
for(int iij1 = ij1+1; iij1 < 1; ++iij1)
{
if( j1valid[iij1] && IKabs(cj1array[ij1]-cj1array[iij1]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij1]-sj1array[iij1]) < IKFAST_SOLUTION_THRESH )
{
    j1valid[iij1]=false; _ij1[1] = iij1; break; 
}
}
j1 = j1array[ij1]; cj1 = cj1array[ij1]; sj1 = sj1array[ij1];
{
IkReal evalcond[6];
IkReal x1729=IKsin(j1);
IkReal x1730=IKcos(j1);
IkReal x1731=((0.2)*cj3);
IkReal x1732=(px*sj2);
IkReal x1733=(cj0*px);
IkReal x1734=((0.64)*sj3);
IkReal x1735=((1.0)*py);
IkReal x1736=((0.64)*cj3);
IkReal x1737=(cj2*px);
IkReal x1738=(py*sj0);
IkReal x1739=((0.2)*sj3);
IkReal x1740=(cj0*x1730);
IkReal x1741=((1.0)*x1729);
IkReal x1742=(cj2*x1730);
IkReal x1743=(cj2*x1729);
IkReal x1744=(pz*x1730);
IkReal x1745=(sj2*x1730);
IkReal x1746=((1.24)*x1729);
evalcond[0]=((-0.62)+(((-1.0)*sj0*x1729*x1735))+(((-1.0)*x1733*x1741))+x1734+x1744+(((0.15)*x1729))+(((-1.0)*x1731)));
evalcond[1]=(((x1736*x1743))+((x1730*x1731))+((x1739*x1743))+(((-1.0)*x1730*x1734))+(((-1.0)*pz))+(((0.62)*x1730)));
evalcond[2]=((((-0.15)*x1745))+((pz*sj2*x1729))+((sj0*x1737))+((x1738*x1745))+((x1732*x1740))+(((-1.0)*cj0*cj2*x1735)));
evalcond[3]=((0.0427)+(((1.24)*x1744))+(((-1.0)*x1733*x1746))+(((-1.0)*x1738*x1746))+(((-1.0)*pp))+(((0.3)*x1738))+(((0.3)*x1733))+(((0.186)*x1729)));
evalcond[4]=((0.15)+((x1736*x1742))+((x1739*x1742))+(((-1.0)*sj0*x1735))+(((-1.0)*x1729*x1731))+(((-0.62)*x1729))+((x1729*x1734))+(((-1.0)*x1733)));
evalcond[5]=((((-1.0)*sj0*x1735*x1742))+(((-1.0)*x1733*x1742))+x1739+x1736+((sj0*x1732))+(((-1.0)*cj0*sj2*x1735))+(((-1.0)*cj2*pz*x1741))+(((0.15)*x1742)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

rotationfunction0(solutions);
}
}

}

}
}
}

}

}
    }
}
return solutions.GetNumSolutions()>0;
}
inline void rotationfunction0(IkSolutionListBase<IkReal>& solutions) {
for(int rotationiter = 0; rotationiter < 1; ++rotationiter) {
IkReal x255=((1.0)*sj2);
IkReal x256=(cj3*sj1);
IkReal x257=(cj1*cj2);
IkReal x258=((1.0)*sj3);
IkReal x259=(cj0*sj3);
IkReal x260=(cj0*sj2);
IkReal x261=(sj1*sj2);
IkReal x262=(sj0*sj2);
IkReal x263=(((cj1*x262))+(((-1.0)*cj0*cj2)));
IkReal x264=(((cj2*sj0))+((cj1*x260)));
IkReal x265=((((-1.0)*x257*x258))+x256);
IkReal x266=(((cj3*x257))+((sj1*sj3)));
IkReal x267=(((cj2*x256))+(((-1.0)*cj1*x258)));
IkReal x268=(sj0*x265);
IkReal x269=((((-1.0)*cj2*sj1*x258))+(((-1.0)*cj1*cj3)));
IkReal x270=(((cj0*x265))+((sj3*x262)));
IkReal x271=((((-1.0)*x255*x259))+x268);
IkReal x272=(((cj3*x260))+((sj0*x266)));
IkReal x273=((((-1.0)*cj3*sj0*x255))+((cj0*x266)));
new_r00=(((r00*x264))+((r10*x263))+((r20*x261)));
new_r01=(((r21*x261))+((r11*x263))+((r01*x264)));
new_r02=(((r22*x261))+((r02*x264))+((r12*x263)));
new_r10=(((r00*x270))+((r10*x271))+((r20*x269)));
new_r11=(((r21*x269))+((r11*((x268+(((-1.0)*sj2*x259))))))+((r01*x270)));
new_r12=(((r02*x270))+((r22*x269))+((r12*x271)));
new_r20=(((r00*x273))+((r10*x272))+((r20*x267)));
new_r21=(((r21*x267))+((r01*x273))+((r11*x272)));
new_r22=(((r02*x273))+((r22*x267))+((r12*x272)));
{
IkReal j5array[2], cj5array[2], sj5array[2];
bool j5valid[2]={false};
_nj5 = 2;
cj5array[0]=new_r22;
if( cj5array[0] >= -1-IKFAST_SINCOS_THRESH && cj5array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j5valid[0] = j5valid[1] = true;
    j5array[0] = IKacos(cj5array[0]);
    sj5array[0] = IKsin(j5array[0]);
    cj5array[1] = cj5array[0];
    j5array[1] = -j5array[0];
    sj5array[1] = -sj5array[0];
}
else if( isnan(cj5array[0]) )
{
    // probably any value will work
    j5valid[0] = true;
    cj5array[0] = 1; sj5array[0] = 0; j5array[0] = 0;
}
for(int ij5 = 0; ij5 < 2; ++ij5)
{
if( !j5valid[ij5] )
{
    continue;
}
_ij5[0] = ij5; _ij5[1] = -1;
for(int iij5 = ij5+1; iij5 < 2; ++iij5)
{
if( j5valid[iij5] && IKabs(cj5array[ij5]-cj5array[iij5]) < IKFAST_SOLUTION_THRESH && IKabs(sj5array[ij5]-sj5array[iij5]) < IKFAST_SOLUTION_THRESH )
{
    j5valid[iij5]=false; _ij5[1] = iij5; break; 
}
}
j5 = j5array[ij5]; cj5 = cj5array[ij5]; sj5 = sj5array[ij5];

{
IkReal j4eval[3];
j4eval[0]=sj5;
j4eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j4eval[2]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj5;
j4eval[1]=new_r12;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r02;
evalcond[2]=new_r20;
evalcond[3]=new_r21;
evalcond[4]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j6mul = 1;
j6=0;
j4mul=-1.0;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4=IKatan2(((-1.0)*new_r01), new_r00);
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].fmul = j6mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r02;
evalcond[2]=new_r20;
evalcond[3]=new_r21;
evalcond[4]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
IkReal j6mul = 1;
j6=0;
j4mul=1.0;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4=IKatan2(new_r01, ((-1.0)*new_r11));
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].fmul = j4mul;
vinfos[4].freeind = 0;
vinfos[4].maxsolutions = 0;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].fmul = j6mul;
vinfos[6].freeind = 0;
vinfos[6].maxsolutions = 0;
std::vector<int> vfree(1);
vfree[0] = 6;
solutions.AddSolution(vinfos,vfree);
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x274=new_r22*new_r22;
IkReal x275=((16.0)*new_r10);
IkReal x276=((16.0)*new_r01);
IkReal x277=((16.0)*new_r00);
IkReal x278=(new_r11*new_r22);
IkReal x279=((8.0)*new_r00);
IkReal x280=(x274*x275);
IkReal x281=(x274*x276);
j4eval[0]=((IKabs((((new_r22*x279))+(((-8.0)*new_r11)))))+(IKabs((x280+(((-1.0)*x275)))))+(IKabs((x276+(((-1.0)*x281)))))+(IKabs((((new_r22*x277))+(((-32.0)*new_r11*x274))+(((16.0)*new_r11)))))+(IKabs(((((32.0)*new_r00))+(((-1.0)*x274*x277))+(((-16.0)*x278)))))+(IKabs((x275+(((-1.0)*x280)))))+(IKabs((x281+(((-1.0)*x276)))))+(IKabs((((x274*x279))+(((-8.0)*x278))))));
if( IKabs(j4eval[0]) < 0.0000000010000000  )
{
continue; // no branches [j4, j6]

} else
{
IkReal op[4+1], zeror[4];
int numroots;
IkReal j4evalpoly[1];
IkReal x282=new_r22*new_r22;
IkReal x283=((16.0)*new_r01);
IkReal x284=(new_r00*new_r22);
IkReal x285=(x282*x283);
IkReal x286=((((8.0)*x284))+(((-8.0)*new_r11)));
op[0]=x286;
op[1]=(x285+(((-1.0)*x283)));
op[2]=((((-32.0)*new_r11*x282))+(((16.0)*x284))+(((16.0)*new_r11)));
op[3]=(x283+(((-1.0)*x285)));
op[4]=x286;
polyroots4(op,zeror,numroots);
IkReal j4array[4], cj4array[4], sj4array[4], tempj4array[1];
int numsolutions = 0;
for(int ij4 = 0; ij4 < numroots; ++ij4)
{
IkReal htj4 = zeror[ij4];
tempj4array[0]=((2.0)*(atan(htj4)));
for(int kj4 = 0; kj4 < 1; ++kj4)
{
j4array[numsolutions] = tempj4array[kj4];
if( j4array[numsolutions] > IKPI )
{
    j4array[numsolutions]-=IK2PI;
}
else if( j4array[numsolutions] < -IKPI )
{
    j4array[numsolutions]+=IK2PI;
}
sj4array[numsolutions] = IKsin(j4array[numsolutions]);
cj4array[numsolutions] = IKcos(j4array[numsolutions]);
numsolutions++;
}
}
bool j4valid[4]={true,true,true,true};
_nj4 = 4;
for(int ij4 = 0; ij4 < numsolutions; ++ij4)
    {
if( !j4valid[ij4] )
{
    continue;
}
    j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
htj4 = IKtan(j4/2);

IkReal x287=new_r22*new_r22;
IkReal x288=((16.0)*new_r10);
IkReal x289=(new_r11*new_r22);
IkReal x290=((8.0)*x289);
IkReal x291=(new_r00*x287);
IkReal x292=(x287*x288);
IkReal x293=((8.0)*x291);
j4evalpoly[0]=((((htj4*htj4*htj4*htj4)*(((((-1.0)*x290))+x293))))+(((htj4*htj4*htj4)*(((((-1.0)*x292))+x288))))+((htj4*((x292+(((-1.0)*x288))))))+(((-1.0)*x290))+x293+(((htj4*htj4)*(((((32.0)*new_r00))+(((-16.0)*x291))+(((-16.0)*x289)))))));
if( IKabs(j4evalpoly[0]) > 0.0000000010000000  )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < numsolutions; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
{
IkReal j6eval[3];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
IkReal x294=new_r22*new_r22;
IkReal x295=cj4*cj4;
IkReal x296=(new_r22*sj4);
IkReal x297=((((-1.0)*x294))+(((-1.0)*x295))+((x294*x295)));
j6eval[0]=x297;
j6eval[1]=IKsign(x297);
j6eval[2]=((IKabs(((((-1.0)*cj4*new_r00))+((new_r01*x296)))))+(IKabs((((cj4*new_r01))+((new_r00*x296))))));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j6eval[0]=new_r22;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j6eval[0]=cj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x298=IKsin(j6);
IkReal x299=IKcos(j6);
evalcond[0]=(x298+new_r11);
evalcond[1]=((-1.0)*x298);
evalcond[2]=((-1.0)*x299);
evalcond[3]=((((-1.0)*x299))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x300=IKsin(j6);
IkReal x301=IKcos(j6);
evalcond[0]=((-1.0)*x300);
evalcond[1]=((-1.0)*x301);
evalcond[2]=(x300+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x301))+(((-1.0)*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x302=new_r22*new_r22;
CheckValue<IkReal> x303=IKPowWithIntegerCheck(((-1.0)+x302),-1);
if(!x303.valid){
continue;
}
if(((x302*(x303.value))) < -0.00001)
continue;
IkReal gconst34=IKsqrt((x302*(x303.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj4)))))+(IKabs((cj4+(((-1.0)*gconst34)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x304=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst34*gconst34))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34)))));
cj4=gconst34;
if( (gconst34) < -1-IKFAST_SINCOS_THRESH || (gconst34) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst34);
CheckValue<IkReal> x305=IKPowWithIntegerCheck(((-1.0)+x304),-1);
if(!x305.valid){
continue;
}
if(((x304*(x305.value))) < -0.00001)
continue;
IkReal gconst34=IKsqrt((x304*(x305.value)));
j6eval[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst34*gconst34))))) < -0.00001)
continue;
CheckValue<IkReal> x306=IKPowWithIntegerCheck(gconst34,-1);
if(!x306.valid){
continue;
}
if( IKabs(((((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34))))))))+(((-1.0)*gconst34*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r00*(x306.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34))))))))+(((-1.0)*gconst34*new_r01))))+IKsqr((new_r00*(x306.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34))))))))+(((-1.0)*gconst34*new_r01))), (new_r00*(x306.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x307=IKsin(j6);
IkReal x308=IKcos(j6);
IkReal x309=((1.0)*x308);
if((((1.0)+(((-1.0)*(gconst34*gconst34))))) < -0.00001)
continue;
IkReal x310=IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34)))));
evalcond[0]=((-1.0)*x307);
evalcond[1]=((-1.0)*x308);
evalcond[2]=(((gconst34*x307))+new_r01);
evalcond[3]=((((-1.0)*gconst34*x309))+new_r00);
evalcond[4]=(((x307*x310))+new_r11);
evalcond[5]=(new_r10+(((-1.0)*x309*x310)));
evalcond[6]=(x307+((new_r11*x310))+((gconst34*new_r01)));
evalcond[7]=(((new_r10*x310))+((gconst34*new_r00))+(((-1.0)*x309)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x311 = IKatan2WithCheck(IkReal(((-1.0)*new_r01)),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x311.valid){
continue;
}
CheckValue<IkReal> x312=IKPowWithIntegerCheck(IKsign(gconst34),-1);
if(!x312.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x311.value)+(((1.5707963267949)*(x312.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x313=IKsin(j6);
IkReal x314=IKcos(j6);
IkReal x315=((1.0)*x314);
if((((1.0)+(((-1.0)*(gconst34*gconst34))))) < -0.00001)
continue;
IkReal x316=IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34)))));
evalcond[0]=((-1.0)*x313);
evalcond[1]=((-1.0)*x314);
evalcond[2]=(((gconst34*x313))+new_r01);
evalcond[3]=((((-1.0)*gconst34*x315))+new_r00);
evalcond[4]=(new_r11+((x313*x316)));
evalcond[5]=((((-1.0)*x315*x316))+new_r10);
evalcond[6]=(x313+((new_r11*x316))+((gconst34*new_r01)));
evalcond[7]=((((-1.0)*x315))+((new_r10*x316))+((gconst34*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x317=new_r22*new_r22;
CheckValue<IkReal> x318=IKPowWithIntegerCheck(((-1.0)+x317),-1);
if(!x318.valid){
continue;
}
if(((x317*(x318.value))) < -0.00001)
continue;
IkReal gconst34=IKsqrt((x317*(x318.value)));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs((cj4+(((-1.0)*gconst34)))))+(IKabs(((1.0)+(IKsign(sj4)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x319=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst34*gconst34))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34)))))));
cj4=gconst34;
if( (gconst34) < -1-IKFAST_SINCOS_THRESH || (gconst34) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst34)));
CheckValue<IkReal> x320=IKPowWithIntegerCheck(((-1.0)+x319),-1);
if(!x320.valid){
continue;
}
if(((x319*(x320.value))) < -0.00001)
continue;
IkReal gconst34=IKsqrt((x319*(x320.value)));
j6eval[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst34*gconst34))))) < -0.00001)
continue;
CheckValue<IkReal> x321=IKPowWithIntegerCheck(gconst34,-1);
if(!x321.valid){
continue;
}
if( IKabs((((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34))))))))+(((-1.0)*gconst34*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r00*(x321.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34))))))))+(((-1.0)*gconst34*new_r01))))+IKsqr((new_r00*(x321.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34))))))))+(((-1.0)*gconst34*new_r01))), (new_r00*(x321.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x322=IKsin(j6);
IkReal x323=IKcos(j6);
IkReal x324=((1.0)*x323);
if((((1.0)+(((-1.0)*(gconst34*gconst34))))) < -0.00001)
continue;
IkReal x325=IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34)))));
IkReal x326=((1.0)*x325);
evalcond[0]=((-1.0)*x322);
evalcond[1]=((-1.0)*x323);
evalcond[2]=(new_r01+((gconst34*x322)));
evalcond[3]=((((-1.0)*gconst34*x324))+new_r00);
evalcond[4]=(((x323*x325))+new_r10);
evalcond[5]=((((-1.0)*x322*x326))+new_r11);
evalcond[6]=(x322+(((-1.0)*new_r11*x326))+((gconst34*new_r01)));
evalcond[7]=((((-1.0)*x324))+(((-1.0)*new_r10*x326))+((gconst34*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x327 = IKatan2WithCheck(IkReal(((-1.0)*new_r01)),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x327.valid){
continue;
}
CheckValue<IkReal> x328=IKPowWithIntegerCheck(IKsign(gconst34),-1);
if(!x328.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x327.value)+(((1.5707963267949)*(x328.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x329=IKsin(j6);
IkReal x330=IKcos(j6);
IkReal x331=((1.0)*x330);
if((((1.0)+(((-1.0)*(gconst34*gconst34))))) < -0.00001)
continue;
IkReal x332=IKsqrt(((1.0)+(((-1.0)*(gconst34*gconst34)))));
IkReal x333=((1.0)*x332);
evalcond[0]=((-1.0)*x329);
evalcond[1]=((-1.0)*x330);
evalcond[2]=(new_r01+((gconst34*x329)));
evalcond[3]=((((-1.0)*gconst34*x331))+new_r00);
evalcond[4]=(((x330*x332))+new_r10);
evalcond[5]=((((-1.0)*x329*x333))+new_r11);
evalcond[6]=((((-1.0)*new_r11*x333))+x329+((gconst34*new_r01)));
evalcond[7]=((((-1.0)*new_r10*x333))+(((-1.0)*x331))+((gconst34*new_r00)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x334=new_r22*new_r22;
CheckValue<IkReal> x335=IKPowWithIntegerCheck(((-1.0)+x334),-1);
if(!x335.valid){
continue;
}
if(((x334*(x335.value))) < -0.00001)
continue;
IkReal gconst35=((-1.0)*(IKsqrt((x334*(x335.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.0)+(IKsign(sj4)))))+(IKabs((cj4+(((-1.0)*gconst35)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x336=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst35*gconst35))))) < -0.00001)
continue;
sj4=IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35)))));
cj4=gconst35;
if( (gconst35) < -1-IKFAST_SINCOS_THRESH || (gconst35) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=IKacos(gconst35);
CheckValue<IkReal> x337=IKPowWithIntegerCheck(((-1.0)+x336),-1);
if(!x337.valid){
continue;
}
if(((x336*(x337.value))) < -0.00001)
continue;
IkReal gconst35=((-1.0)*(IKsqrt((x336*(x337.value)))));
j6eval[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst35*gconst35))))) < -0.00001)
continue;
CheckValue<IkReal> x338=IKPowWithIntegerCheck(gconst35,-1);
if(!x338.valid){
continue;
}
if( IKabs(((((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35))))))))+(((-1.0)*gconst35*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r00*(x338.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35))))))))+(((-1.0)*gconst35*new_r01))))+IKsqr((new_r00*(x338.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35))))))))+(((-1.0)*gconst35*new_r01))), (new_r00*(x338.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x339=IKsin(j6);
IkReal x340=IKcos(j6);
IkReal x341=((1.0)*x340);
if((((1.0)+(((-1.0)*(gconst35*gconst35))))) < -0.00001)
continue;
IkReal x342=IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35)))));
evalcond[0]=((-1.0)*x339);
evalcond[1]=((-1.0)*x340);
evalcond[2]=(((gconst35*x339))+new_r01);
evalcond[3]=((((-1.0)*gconst35*x341))+new_r00);
evalcond[4]=(new_r11+((x339*x342)));
evalcond[5]=((((-1.0)*x341*x342))+new_r10);
evalcond[6]=(((gconst35*new_r01))+((new_r11*x342))+x339);
evalcond[7]=(((gconst35*new_r00))+((new_r10*x342))+(((-1.0)*x341)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x343 = IKatan2WithCheck(IkReal(((-1.0)*new_r01)),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x343.valid){
continue;
}
CheckValue<IkReal> x344=IKPowWithIntegerCheck(IKsign(gconst35),-1);
if(!x344.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x343.value)+(((1.5707963267949)*(x344.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x345=IKsin(j6);
IkReal x346=IKcos(j6);
IkReal x347=((1.0)*x346);
if((((1.0)+(((-1.0)*(gconst35*gconst35))))) < -0.00001)
continue;
IkReal x348=IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35)))));
evalcond[0]=((-1.0)*x345);
evalcond[1]=((-1.0)*x346);
evalcond[2]=(new_r01+((gconst35*x345)));
evalcond[3]=((((-1.0)*gconst35*x347))+new_r00);
evalcond[4]=(((x345*x348))+new_r11);
evalcond[5]=((((-1.0)*x347*x348))+new_r10);
evalcond[6]=(((gconst35*new_r01))+((new_r11*x348))+x345);
evalcond[7]=(((gconst35*new_r00))+((new_r10*x348))+(((-1.0)*x347)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x349=new_r22*new_r22;
CheckValue<IkReal> x350=IKPowWithIntegerCheck(((-1.0)+x349),-1);
if(!x350.valid){
continue;
}
if(((x349*(x350.value))) < -0.00001)
continue;
IkReal gconst35=((-1.0)*(IKsqrt((x349*(x350.value)))));
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.0)+(IKsign(sj4)))))+(IKabs((cj4+(((-1.0)*gconst35)))))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
IkReal x351=new_r22*new_r22;
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
if((((1.0)+(((-1.0)*(gconst35*gconst35))))) < -0.00001)
continue;
sj4=((-1.0)*(IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35)))))));
cj4=gconst35;
if( (gconst35) < -1-IKFAST_SINCOS_THRESH || (gconst35) > 1+IKFAST_SINCOS_THRESH )
    continue;
j4=((-1.0)*(IKacos(gconst35)));
CheckValue<IkReal> x352=IKPowWithIntegerCheck(((-1.0)+x351),-1);
if(!x352.valid){
continue;
}
if(((x351*(x352.value))) < -0.00001)
continue;
IkReal gconst35=((-1.0)*(IKsqrt((x351*(x352.value)))));
j6eval[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if((((1.0)+(((-1.0)*(gconst35*gconst35))))) < -0.00001)
continue;
CheckValue<IkReal> x353=IKPowWithIntegerCheck(gconst35,-1);
if(!x353.valid){
continue;
}
if( IKabs((((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35))))))))+(((-1.0)*gconst35*new_r01)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r00*(x353.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35))))))))+(((-1.0)*gconst35*new_r01))))+IKsqr((new_r00*(x353.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((((new_r11*(IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35))))))))+(((-1.0)*gconst35*new_r01))), (new_r00*(x353.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x354=IKsin(j6);
IkReal x355=IKcos(j6);
IkReal x356=((1.0)*x355);
if((((1.0)+(((-1.0)*(gconst35*gconst35))))) < -0.00001)
continue;
IkReal x357=IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35)))));
IkReal x358=((1.0)*x357);
evalcond[0]=((-1.0)*x354);
evalcond[1]=((-1.0)*x355);
evalcond[2]=(((gconst35*x354))+new_r01);
evalcond[3]=((((-1.0)*gconst35*x356))+new_r00);
evalcond[4]=(((x355*x357))+new_r10);
evalcond[5]=(new_r11+(((-1.0)*x354*x358)));
evalcond[6]=(((gconst35*new_r01))+x354+(((-1.0)*new_r11*x358)));
evalcond[7]=(((gconst35*new_r00))+(((-1.0)*x356))+(((-1.0)*new_r10*x358)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x359 = IKatan2WithCheck(IkReal(((-1.0)*new_r01)),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x359.valid){
continue;
}
CheckValue<IkReal> x360=IKPowWithIntegerCheck(IKsign(gconst35),-1);
if(!x360.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x359.value)+(((1.5707963267949)*(x360.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x361=IKsin(j6);
IkReal x362=IKcos(j6);
IkReal x363=((1.0)*x362);
if((((1.0)+(((-1.0)*(gconst35*gconst35))))) < -0.00001)
continue;
IkReal x364=IKsqrt(((1.0)+(((-1.0)*(gconst35*gconst35)))));
IkReal x365=((1.0)*x364);
evalcond[0]=((-1.0)*x361);
evalcond[1]=((-1.0)*x362);
evalcond[2]=(((gconst35*x361))+new_r01);
evalcond[3]=(new_r00+(((-1.0)*gconst35*x363)));
evalcond[4]=(new_r10+((x362*x364)));
evalcond[5]=((((-1.0)*x361*x365))+new_r11);
evalcond[6]=(((gconst35*new_r01))+x361+(((-1.0)*new_r11*x365)));
evalcond[7]=(((gconst35*new_r00))+(((-1.0)*x363))+(((-1.0)*new_r10*x365)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x366=(new_r11*new_r22);
IkReal x367=((1.0)*cj4*new_r01);
CheckValue<IkReal> x368=IKPowWithIntegerCheck(cj4,-1);
if(!x368.valid){
continue;
}
if( IKabs(((((-1.0)*x367))+(((-1.0)*new_r11*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x368.value)*(((((-1.0)*x366))+(((-1.0)*new_r22*sj4*x367))+((x366*(cj4*cj4)))+new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x367))+(((-1.0)*new_r11*sj4))))+IKsqr(((x368.value)*(((((-1.0)*x366))+(((-1.0)*new_r22*sj4*x367))+((x366*(cj4*cj4)))+new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*x367))+(((-1.0)*new_r11*sj4))), ((x368.value)*(((((-1.0)*x366))+(((-1.0)*new_r22*sj4*x367))+((x366*(cj4*cj4)))+new_r00))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x369=IKcos(j6);
IkReal x370=IKsin(j6);
IkReal x371=(cj4*new_r22);
IkReal x372=((1.0)*sj4);
IkReal x373=((1.0)*x369);
IkReal x374=(sj4*x370);
IkReal x375=((1.0)*x370);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x370);
evalcond[1]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x373)));
evalcond[2]=(((new_r22*sj4*x369))+((cj4*x370))+new_r01);
evalcond[3]=((((-1.0)*cj4*x373))+new_r00+((new_r22*x374)));
evalcond[4]=(x374+(((-1.0)*x371*x373))+new_r11);
evalcond[5]=((((-1.0)*new_r00*x372))+((cj4*new_r10))+(((-1.0)*new_r22*x375)));
evalcond[6]=(((cj4*new_r11))+(((-1.0)*new_r22*x373))+(((-1.0)*new_r01*x372)));
evalcond[7]=((((-1.0)*x371*x375))+(((-1.0)*x369*x372))+new_r10);
evalcond[8]=((((-1.0)*x375))+(((-1.0)*new_r00*new_r22*x372))+((new_r10*x371)));
evalcond[9]=((((-1.0)*x373))+(((-1.0)*new_r01*new_r22*x372))+((new_r11*x371)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x376=((1.0)*sj4);
CheckValue<IkReal> x377=IKPowWithIntegerCheck(new_r22,-1);
if(!x377.valid){
continue;
}
if( IKabs(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x376)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x377.value)*((((cj4*new_r11))+(((-1.0)*new_r01*x376)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x376))))+IKsqr(((x377.value)*((((cj4*new_r11))+(((-1.0)*new_r01*x376))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*new_r01))+(((-1.0)*new_r11*x376))), ((x377.value)*((((cj4*new_r11))+(((-1.0)*new_r01*x376))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x378=IKcos(j6);
IkReal x379=IKsin(j6);
IkReal x380=(cj4*new_r22);
IkReal x381=((1.0)*sj4);
IkReal x382=((1.0)*x378);
IkReal x383=(sj4*x379);
IkReal x384=((1.0)*x379);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x379);
evalcond[1]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x382)));
evalcond[2]=(((new_r22*sj4*x378))+((cj4*x379))+new_r01);
evalcond[3]=(((new_r22*x383))+(((-1.0)*cj4*x382))+new_r00);
evalcond[4]=((((-1.0)*x380*x382))+x383+new_r11);
evalcond[5]=(((cj4*new_r10))+(((-1.0)*new_r00*x381))+(((-1.0)*new_r22*x384)));
evalcond[6]=(((cj4*new_r11))+(((-1.0)*new_r01*x381))+(((-1.0)*new_r22*x382)));
evalcond[7]=((((-1.0)*x380*x384))+(((-1.0)*x378*x381))+new_r10);
evalcond[8]=((((-1.0)*new_r00*new_r22*x381))+((new_r10*x380))+(((-1.0)*x384)));
evalcond[9]=((((-1.0)*new_r01*new_r22*x381))+((new_r11*x380))+(((-1.0)*x382)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x385=new_r22*new_r22;
IkReal x386=cj4*cj4;
IkReal x387=(new_r22*sj4);
CheckValue<IkReal> x388 = IKatan2WithCheck(IkReal((((cj4*new_r01))+((new_r00*x387)))),IkReal(((((-1.0)*cj4*new_r00))+((new_r01*x387)))),IKFAST_ATAN2_MAGTHRESH);
if(!x388.valid){
continue;
}
CheckValue<IkReal> x389=IKPowWithIntegerCheck(IKsign(((((-1.0)*x385))+(((-1.0)*x386))+((x385*x386)))),-1);
if(!x389.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(x388.value)+(((1.5707963267949)*(x389.value))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[10];
IkReal x390=IKcos(j6);
IkReal x391=IKsin(j6);
IkReal x392=(cj4*new_r22);
IkReal x393=((1.0)*sj4);
IkReal x394=((1.0)*x390);
IkReal x395=(sj4*x391);
IkReal x396=((1.0)*x391);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x391);
evalcond[1]=((((-1.0)*x394))+((cj4*new_r00))+((new_r10*sj4)));
evalcond[2]=(((new_r22*sj4*x390))+((cj4*x391))+new_r01);
evalcond[3]=((((-1.0)*cj4*x394))+new_r00+((new_r22*x395)));
evalcond[4]=(x395+new_r11+(((-1.0)*x392*x394)));
evalcond[5]=((((-1.0)*new_r22*x396))+((cj4*new_r10))+(((-1.0)*new_r00*x393)));
evalcond[6]=((((-1.0)*new_r01*x393))+(((-1.0)*new_r22*x394))+((cj4*new_r11)));
evalcond[7]=((((-1.0)*x390*x393))+new_r10+(((-1.0)*x392*x396)));
evalcond[8]=((((-1.0)*x396))+(((-1.0)*new_r00*new_r22*x393))+((new_r10*x392)));
evalcond[9]=(((new_r11*x392))+(((-1.0)*x394))+(((-1.0)*new_r01*new_r22*x393)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4, j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x398=IKPowWithIntegerCheck(sj5,-1);
if(!x398.valid){
continue;
}
IkReal x397=x398.value;
CheckValue<IkReal> x399=IKPowWithIntegerCheck(new_r12,-1);
if(!x399.valid){
continue;
}
if( IKabs(((-1.0)*new_r02*x397)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x397*(x399.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5))))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r02*x397))+IKsqr((x397*(x399.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r02*x397), (x397*(x399.value)*(((1.0)+(((-1.0)*(new_r02*new_r02)))+(((-1.0)*(cj5*cj5)))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x400=IKcos(j4);
IkReal x401=IKsin(j4);
IkReal x402=((1.0)*sj5);
IkReal x403=((1.0)*cj5);
IkReal x404=(new_r02*x401);
IkReal x405=(new_r12*x400);
IkReal x406=(sj5*x401);
evalcond[0]=(x406+new_r02);
evalcond[1]=((((-1.0)*x400*x402))+new_r12);
evalcond[2]=(((new_r12*x401))+((new_r02*x400)));
evalcond[3]=(x405+(((-1.0)*x404))+(((-1.0)*x402)));
evalcond[4]=((((-1.0)*x403*x404))+((cj5*x405))+(((-1.0)*new_r22*x402)));
evalcond[5]=((((-1.0)*new_r20*x403))+(((-1.0)*new_r10*x400*x402))+((new_r00*x406)));
evalcond[6]=((((-1.0)*new_r21*x403))+((new_r01*x406))+(((-1.0)*new_r11*x400*x402)));
evalcond[7]=((1.0)+(((-1.0)*x402*x405))+((sj5*x404))+(((-1.0)*new_r22*x403)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
j6eval[0]=cj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=cj5;
j6eval[2]=sj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r02;
evalcond[2]=new_r20;
evalcond[3]=new_r21;
evalcond[4]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x407=((1.0)*new_r01);
if( IKabs(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x407)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x407)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x407))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x407))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*new_r00*sj4))+(((-1.0)*cj4*x407))), (((cj4*new_r00))+(((-1.0)*sj4*x407))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x408=IKcos(j6);
IkReal x409=IKsin(j6);
IkReal x410=((1.0)*sj4);
IkReal x411=(sj4*x409);
IkReal x412=((1.0)*x408);
IkReal x413=(sj4*x408);
IkReal x414=(cj4*x409);
IkReal x415=(cj4*x412);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x409);
evalcond[1]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x412)));
evalcond[2]=(x413+x414+new_r01);
evalcond[3]=(x411+new_r00+(((-1.0)*x415)));
evalcond[4]=(x411+new_r11+(((-1.0)*x415)));
evalcond[5]=(((cj4*new_r10))+(((-1.0)*new_r00*x410))+(((-1.0)*x409)));
evalcond[6]=(((cj4*new_r11))+(((-1.0)*x412))+(((-1.0)*new_r01*x410)));
evalcond[7]=(new_r10+(((-1.0)*x408*x410))+(((-1.0)*x414)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r02;
evalcond[2]=new_r20;
evalcond[3]=new_r21;
evalcond[4]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x416=((1.0)*new_r11);
if( IKabs(((((-1.0)*cj4*new_r01))+(((-1.0)*sj4*x416)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj4))+(((-1.0)*cj4*x416)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*new_r01))+(((-1.0)*sj4*x416))))+IKsqr((((new_r01*sj4))+(((-1.0)*cj4*x416))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*new_r01))+(((-1.0)*sj4*x416))), (((new_r01*sj4))+(((-1.0)*cj4*x416))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x417=IKsin(j6);
IkReal x418=IKcos(j6);
IkReal x419=((1.0)*sj4);
IkReal x420=(cj4*x417);
IkReal x421=((1.0)*x418);
IkReal x422=(x418*x419);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x417);
evalcond[1]=(((cj4*new_r10))+x417+(((-1.0)*new_r00*x419)));
evalcond[2]=(((cj4*new_r11))+x418+(((-1.0)*new_r01*x419)));
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x421)));
evalcond[4]=(((cj4*x418))+new_r11+((sj4*x417)));
evalcond[5]=((((-1.0)*x422))+x420+new_r01);
evalcond[6]=((((-1.0)*x422))+x420+new_r10);
evalcond[7]=((((-1.0)*x417*x419))+(((-1.0)*cj4*x421))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x423=IKsin(j6);
IkReal x424=IKcos(j6);
IkReal x425=((1.0)*x424);
evalcond[0]=(x423+new_r20);
evalcond[1]=(x424+new_r21);
evalcond[2]=(((cj4*x423))+new_r01);
evalcond[3]=(((sj4*x423))+new_r11);
evalcond[4]=(new_r10+((new_r02*x424)));
evalcond[5]=((((-1.0)*cj4*x425))+new_r00);
evalcond[6]=(((cj4*new_r01))+((new_r11*sj4))+x423);
evalcond[7]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x425)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r20, new_r21);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x426=IKsin(j6);
IkReal x427=IKcos(j6);
IkReal x428=((1.0)*x427);
evalcond[0]=((((-1.0)*x426))+new_r20);
evalcond[1]=((((-1.0)*x428))+new_r21);
evalcond[2]=(((cj4*x426))+new_r01);
evalcond[3]=(((sj4*x426))+new_r11);
evalcond[4]=((((-1.0)*cj4*x428))+new_r00);
evalcond[5]=((((-1.0)*new_r02*x428))+new_r10);
evalcond[6]=(((cj4*new_r01))+((new_r11*sj4))+x426);
evalcond[7]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x428)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x429=IKsin(j6);
IkReal x430=IKcos(j6);
IkReal x431=((1.0)*sj5);
IkReal x432=((1.0)*x430);
IkReal x433=((1.0)*x429);
evalcond[0]=(x429+new_r01);
evalcond[1]=(((new_r12*x429))+new_r20);
evalcond[2]=(((new_r12*x430))+new_r21);
evalcond[3]=((((-1.0)*x432))+new_r00);
evalcond[4]=((((-1.0)*cj5*x432))+new_r11);
evalcond[5]=((((-1.0)*cj5*x433))+new_r10);
evalcond[6]=((((-1.0)*x433))+((cj5*new_r10))+(((-1.0)*new_r20*x431)));
evalcond[7]=((((-1.0)*x432))+((cj5*new_r11))+(((-1.0)*new_r21*x431)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x434=IKsin(j6);
IkReal x435=IKcos(j6);
CheckValue<IkReal> x441=IKPowWithIntegerCheck(new_r12,-1);
if(!x441.valid){
continue;
}
IkReal x436=x441.value;
IkReal x437=new_r22*new_r22;
IkReal x438=((1.0)*x435);
IkReal x439=(x436*x437);
IkReal x440=((1.0)*x434);
evalcond[0]=(x434+(((-1.0)*new_r01)));
evalcond[1]=(((cj5*x435))+new_r11);
evalcond[2]=(new_r20+(((-1.0)*new_r12*x440)));
evalcond[3]=((((-1.0)*new_r12*x438))+new_r21);
evalcond[4]=((((-1.0)*x438))+(((-1.0)*new_r00)));
evalcond[5]=((((-1.0)*cj5*x440))+(((-1.0)*new_r10)));
evalcond[6]=((((-1.0)*x440))+((new_r12*new_r20))+((new_r20*x439)));
evalcond[7]=((((-1.0)*x438))+((new_r21*x439))+((new_r12*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x442=IKcos(j6);
IkReal x443=IKsin(j6);
CheckValue<IkReal> x449=IKPowWithIntegerCheck(new_r02,-1);
if(!x449.valid){
continue;
}
IkReal x444=x449.value;
IkReal x445=new_r22*new_r22;
IkReal x446=((1.0)*x442);
IkReal x447=(x444*x445);
IkReal x448=((1.0)*x443);
evalcond[0]=(x443+new_r11);
evalcond[1]=((((-1.0)*x446))+new_r10);
evalcond[2]=(((cj5*x442))+new_r01);
evalcond[3]=(((cj5*x443))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x448))+new_r20);
evalcond[5]=((((-1.0)*new_r02*x446))+new_r21);
evalcond[6]=((((-1.0)*x448))+((new_r20*x447))+((new_r02*new_r20)));
evalcond[7]=((((-1.0)*x446))+((new_r21*x447))+((new_r02*new_r21)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
j6eval[0]=new_r02;
j6eval[1]=IKsign(new_r02);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
j6eval[0]=new_r02;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
j6eval[0]=new_r02;
j6eval[1]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r11, ((-1.0)*new_r21));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x450=IKsin(j6);
IkReal x451=IKcos(j6);
evalcond[0]=(x450+new_r20);
evalcond[1]=(x451+new_r21);
evalcond[2]=(x450+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x451))+(((-1.0)*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r20, new_r21);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x452=IKsin(j6);
IkReal x453=((1.0)*(IKcos(j6)));
evalcond[0]=((((-1.0)*x452))+new_r20);
evalcond[1]=((((-1.0)*x453))+new_r21);
evalcond[2]=(x452+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*x453))+(((-1.0)*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r02);
evalcond[1]=new_r20;
evalcond[2]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x454=IKsin(j6);
IkReal x455=IKcos(j6);
IkReal x456=((1.0)*x455);
IkReal x457=((1.0)*x454);
evalcond[0]=(x454+(((-1.0)*new_r11)));
evalcond[1]=((((-1.0)*cj5*x456))+new_r01);
evalcond[2]=((((-1.0)*cj5*x457))+new_r00);
evalcond[3]=((((-1.0)*x456))+(((-1.0)*new_r10)));
evalcond[4]=(((cj5*new_r00))+(((-1.0)*x457)));
evalcond[5]=(((cj5*new_r01))+(((-1.0)*x456)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x458=IKcos(j6);
IkReal x459=IKsin(j6);
IkReal x460=((-1.0)*x458);
IkReal x461=((-1.0)*x459);
evalcond[0]=x461;
evalcond[1]=x460;
evalcond[2]=(new_r22*x460);
evalcond[3]=(new_r22*x461);
evalcond[4]=(x459+(((-1.0)*new_r11)));
evalcond[5]=((((-1.0)*x458))+(((-1.0)*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x462=IKPowWithIntegerCheck(new_r02,-1);
if(!x462.valid){
continue;
}
CheckValue<IkReal> x463=IKPowWithIntegerCheck(cj5,-1);
if(!x463.valid){
continue;
}
if( IKabs(((-1.0)*new_r20*(x462.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r01*(x463.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20*(x462.value)))+IKsqr((new_r01*(x463.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r20*(x462.value)), (new_r01*(x463.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x464=IKsin(j6);
IkReal x465=IKcos(j6);
IkReal x466=((1.0)*sj5);
IkReal x467=((1.0)*x465);
IkReal x468=((1.0)*x464);
evalcond[0]=(((new_r02*x464))+new_r20);
evalcond[1]=(((new_r02*x465))+new_r21);
evalcond[2]=(x464+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*cj5*x467))+new_r01);
evalcond[4]=((((-1.0)*cj5*x468))+new_r00);
evalcond[5]=((((-1.0)*x467))+(((-1.0)*new_r10)));
evalcond[6]=((((-1.0)*new_r20*x466))+((cj5*new_r00))+(((-1.0)*x468)));
evalcond[7]=((((-1.0)*new_r21*x466))+((cj5*new_r01))+(((-1.0)*x467)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x469=IKPowWithIntegerCheck(new_r02,-1);
if(!x469.valid){
continue;
}
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21*(x469.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r21*(x469.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r11, ((-1.0)*new_r21*(x469.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x470=IKsin(j6);
IkReal x471=IKcos(j6);
IkReal x472=((1.0)*sj5);
IkReal x473=((1.0)*x471);
IkReal x474=((1.0)*x470);
evalcond[0]=(((new_r02*x470))+new_r20);
evalcond[1]=(((new_r02*x471))+new_r21);
evalcond[2]=(x470+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*cj5*x473))+new_r01);
evalcond[4]=((((-1.0)*cj5*x474))+new_r00);
evalcond[5]=((((-1.0)*x473))+(((-1.0)*new_r10)));
evalcond[6]=(((cj5*new_r00))+(((-1.0)*x474))+(((-1.0)*new_r20*x472)));
evalcond[7]=((((-1.0)*new_r21*x472))+((cj5*new_r01))+(((-1.0)*x473)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x475=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x475.valid){
continue;
}
CheckValue<IkReal> x476 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),IkReal(((-1.0)*new_r21)),IKFAST_ATAN2_MAGTHRESH);
if(!x476.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x475.value)))+(x476.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x477=IKsin(j6);
IkReal x478=IKcos(j6);
IkReal x479=((1.0)*sj5);
IkReal x480=((1.0)*x478);
IkReal x481=((1.0)*x477);
evalcond[0]=(((new_r02*x477))+new_r20);
evalcond[1]=(((new_r02*x478))+new_r21);
evalcond[2]=(x477+(((-1.0)*new_r11)));
evalcond[3]=(new_r01+(((-1.0)*cj5*x480)));
evalcond[4]=(new_r00+(((-1.0)*cj5*x481)));
evalcond[5]=((((-1.0)*x480))+(((-1.0)*new_r10)));
evalcond[6]=((((-1.0)*x481))+((cj5*new_r00))+(((-1.0)*new_r20*x479)));
evalcond[7]=((((-1.0)*x480))+(((-1.0)*new_r21*x479))+((cj5*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j6eval[0]=1.0;
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j6]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=-1.0;
op[1]=0;
op[2]=1.0;
polyroots2(op,zeror,numroots);
IkReal j6array[2], cj6array[2], sj6array[2], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[2]={true,true};
_nj6 = 2;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x483=IKPowWithIntegerCheck(sj5,-1);
if(!x483.valid){
continue;
}
IkReal x482=x483.value;
CheckValue<IkReal> x484=IKPowWithIntegerCheck(cj5,-1);
if(!x484.valid){
continue;
}
CheckValue<IkReal> x485=IKPowWithIntegerCheck(sj4,-1);
if(!x485.valid){
continue;
}
if( IKabs(((-1.0)*new_r20*x482)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x482*(x484.value)*(x485.value)*(((((-1.0)*new_r01*sj5))+((cj4*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20*x482))+IKsqr((x482*(x484.value)*(x485.value)*(((((-1.0)*new_r01*sj5))+((cj4*new_r20))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r20*x482), (x482*(x484.value)*(x485.value)*(((((-1.0)*new_r01*sj5))+((cj4*new_r20))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x486=IKsin(j6);
IkReal x487=IKcos(j6);
IkReal x488=((1.0)*sj4);
IkReal x489=(cj4*cj5);
IkReal x490=((1.0)*sj5);
IkReal x491=((1.0)*x487);
IkReal x492=((1.0)*x486);
IkReal x493=(sj4*x486);
evalcond[0]=(((sj5*x486))+new_r20);
evalcond[1]=(((sj5*x487))+new_r21);
evalcond[2]=(((cj4*new_r01))+((new_r11*sj4))+x486);
evalcond[3]=((((-1.0)*x491))+((cj4*new_r00))+((new_r10*sj4)));
evalcond[4]=(((cj5*sj4*x487))+((cj4*x486))+new_r01);
evalcond[5]=(((cj5*x493))+(((-1.0)*cj4*x491))+new_r00);
evalcond[6]=((((-1.0)*x489*x491))+x493+new_r11);
evalcond[7]=((((-1.0)*new_r00*x488))+((cj4*new_r10))+(((-1.0)*cj5*x492)));
evalcond[8]=((((-1.0)*new_r01*x488))+((cj4*new_r11))+(((-1.0)*cj5*x491)));
evalcond[9]=((((-1.0)*x489*x492))+(((-1.0)*x487*x488))+new_r10);
evalcond[10]=((((-1.0)*new_r20*x490))+(((-1.0)*x492))+(((-1.0)*cj5*new_r00*x488))+((new_r10*x489)));
evalcond[11]=((((-1.0)*x491))+(((-1.0)*new_r21*x490))+((new_r11*x489))+(((-1.0)*cj5*new_r01*x488)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x495=IKPowWithIntegerCheck(sj5,-1);
if(!x495.valid){
continue;
}
IkReal x494=x495.value;
CheckValue<IkReal> x496=IKPowWithIntegerCheck(cj4,-1);
if(!x496.valid){
continue;
}
if( IKabs((x494*(x496.value)*(((((-1.0)*new_r01*sj5))+((cj5*new_r21*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21*x494)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x494*(x496.value)*(((((-1.0)*new_r01*sj5))+((cj5*new_r21*sj4))))))+IKsqr(((-1.0)*new_r21*x494))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x494*(x496.value)*(((((-1.0)*new_r01*sj5))+((cj5*new_r21*sj4))))), ((-1.0)*new_r21*x494));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x497=IKsin(j6);
IkReal x498=IKcos(j6);
IkReal x499=((1.0)*sj4);
IkReal x500=(cj4*cj5);
IkReal x501=((1.0)*sj5);
IkReal x502=((1.0)*x498);
IkReal x503=((1.0)*x497);
IkReal x504=(sj4*x497);
evalcond[0]=(new_r20+((sj5*x497)));
evalcond[1]=(new_r21+((sj5*x498)));
evalcond[2]=(((cj4*new_r01))+((new_r11*sj4))+x497);
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x502)));
evalcond[4]=(((cj5*sj4*x498))+((cj4*x497))+new_r01);
evalcond[5]=((((-1.0)*cj4*x502))+((cj5*x504))+new_r00);
evalcond[6]=(x504+new_r11+(((-1.0)*x500*x502)));
evalcond[7]=((((-1.0)*new_r00*x499))+((cj4*new_r10))+(((-1.0)*cj5*x503)));
evalcond[8]=((((-1.0)*new_r01*x499))+((cj4*new_r11))+(((-1.0)*cj5*x502)));
evalcond[9]=((((-1.0)*x498*x499))+new_r10+(((-1.0)*x500*x503)));
evalcond[10]=((((-1.0)*cj5*new_r00*x499))+(((-1.0)*new_r20*x501))+(((-1.0)*x503))+((new_r10*x500)));
evalcond[11]=((((-1.0)*new_r21*x501))+(((-1.0)*cj5*new_r01*x499))+(((-1.0)*x502))+((new_r11*x500)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x505=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x505.valid){
continue;
}
CheckValue<IkReal> x506 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),IkReal(((-1.0)*new_r21)),IKFAST_ATAN2_MAGTHRESH);
if(!x506.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x505.value)))+(x506.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x507=IKsin(j6);
IkReal x508=IKcos(j6);
IkReal x509=((1.0)*sj4);
IkReal x510=(cj4*cj5);
IkReal x511=((1.0)*sj5);
IkReal x512=((1.0)*x508);
IkReal x513=((1.0)*x507);
IkReal x514=(sj4*x507);
evalcond[0]=(((sj5*x507))+new_r20);
evalcond[1]=(((sj5*x508))+new_r21);
evalcond[2]=(((cj4*new_r01))+((new_r11*sj4))+x507);
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x512)));
evalcond[4]=(((cj4*x507))+((cj5*sj4*x508))+new_r01);
evalcond[5]=(((cj5*x514))+(((-1.0)*cj4*x512))+new_r00);
evalcond[6]=(x514+new_r11+(((-1.0)*x510*x512)));
evalcond[7]=((((-1.0)*new_r00*x509))+((cj4*new_r10))+(((-1.0)*cj5*x513)));
evalcond[8]=((((-1.0)*new_r01*x509))+((cj4*new_r11))+(((-1.0)*cj5*x512)));
evalcond[9]=((((-1.0)*x508*x509))+new_r10+(((-1.0)*x510*x513)));
evalcond[10]=(((new_r10*x510))+(((-1.0)*new_r20*x511))+(((-1.0)*x513))+(((-1.0)*cj5*new_r00*x509)));
evalcond[11]=(((new_r11*x510))+(((-1.0)*new_r21*x511))+(((-1.0)*x512))+(((-1.0)*cj5*new_r01*x509)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x515=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x515.valid){
continue;
}
CheckValue<IkReal> x516 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),IkReal(((-1.0)*new_r21)),IKFAST_ATAN2_MAGTHRESH);
if(!x516.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x515.value)))+(x516.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[2];
evalcond[0]=(((sj5*(IKsin(j6))))+new_r20);
evalcond[1]=(new_r21+((sj5*(IKcos(j6)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[3];
j4eval[0]=sj5;
j4eval[1]=((IKabs(new_r12))+(IKabs(new_r02)));
j4eval[2]=IKsign(sj5);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj5;
j4eval[1]=new_r01;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r02;
evalcond[2]=new_r20;
evalcond[3]=new_r21;
evalcond[4]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x517=((1.0)*sj6);
if( IKabs(((((-1.0)*cj6*new_r01))+(((-1.0)*new_r00*x517)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*new_r01*x517))+((cj6*new_r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj6*new_r01))+(((-1.0)*new_r00*x517))))+IKsqr(((((-1.0)*new_r01*x517))+((cj6*new_r00))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj6*new_r01))+(((-1.0)*new_r00*x517))), ((((-1.0)*new_r01*x517))+((cj6*new_r00))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x518=IKcos(j4);
IkReal x519=IKsin(j4);
IkReal x520=((1.0)*cj6);
IkReal x521=(sj6*x519);
IkReal x522=(cj6*x519);
IkReal x523=(sj6*x518);
IkReal x524=((1.0)*x519);
IkReal x525=(x518*x520);
evalcond[0]=(((new_r01*x518))+((new_r11*x519))+sj6);
evalcond[1]=(x522+x523+new_r01);
evalcond[2]=((((-1.0)*x525))+x521+new_r00);
evalcond[3]=((((-1.0)*x525))+x521+new_r11);
evalcond[4]=(((new_r00*x518))+((new_r10*x519))+(((-1.0)*x520)));
evalcond[5]=((((-1.0)*x523))+new_r10+(((-1.0)*x519*x520)));
evalcond[6]=(((new_r10*x518))+(((-1.0)*sj6))+(((-1.0)*new_r00*x524)));
evalcond[7]=(((new_r11*x518))+(((-1.0)*x520))+(((-1.0)*new_r01*x524)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r02;
evalcond[2]=new_r20;
evalcond[3]=new_r21;
evalcond[4]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x526=(((new_r11*sj6))+((cj6*new_r01)));
j4eval[0]=x526;
j4eval[1]=((IKabs(((-1.0)+(new_r01*new_r01)+(cj6*cj6))))+(IKabs(((((-1.0)*new_r01*new_r11))+(((-1.0)*cj6*sj6))))));
j4eval[2]=IKsign(x526);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x527=((1.0)*sj6);
IkReal x528=(((new_r10*new_r11))+((new_r00*new_r01)));
j4eval[0]=x528;
j4eval[1]=IKsign(x528);
j4eval[2]=((IKabs(((((-1.0)*new_r00*x527))+(((-1.0)*new_r11*x527)))))+(IKabs((((new_r01*sj6))+(((-1.0)*new_r10*x527))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
IkReal x529=((1.0)*new_r11);
IkReal x530=((new_r01*new_r01)+(new_r11*new_r11));
j4eval[0]=x530;
j4eval[1]=((IKabs(((((-1.0)*new_r01*sj6))+(((-1.0)*cj6*x529)))))+(IKabs(((((-1.0)*sj6*x529))+((cj6*new_r01))))));
j4eval[2]=IKsign(x530);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r01=0;
new_r11=0;
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x532 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x532.valid){
continue;
}
IkReal x531=x532.value;
j4array[0]=((-1.0)*x531);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x531)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r10*(IKcos(j4))))+(((-1.0)*new_r00*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j6))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r11))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(new_r01, ((-1.0)*new_r11));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x533=IKcos(j4);
IkReal x534=IKsin(j4);
IkReal x535=((1.0)*x534);
evalcond[0]=(x533+new_r11);
evalcond[1]=((((-1.0)*x535))+new_r01);
evalcond[2]=((((-1.0)*x533))+new_r00);
evalcond[3]=((((-1.0)*x535))+new_r10);
evalcond[4]=(((new_r01*x533))+((new_r11*x534)));
evalcond[5]=((-1.0)+((new_r10*x534))+((new_r00*x533)));
evalcond[6]=((((-1.0)*new_r00*x535))+((new_r10*x533)));
evalcond[7]=((1.0)+((new_r11*x533))+(((-1.0)*new_r01*x535)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r01), ((-1.0)*new_r00));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x536=IKsin(j4);
IkReal x537=IKcos(j4);
IkReal x538=((1.0)*x536);
evalcond[0]=(x536+new_r01);
evalcond[1]=(x537+new_r00);
evalcond[2]=(x536+new_r10);
evalcond[3]=((((-1.0)*x537))+new_r11);
evalcond[4]=(((new_r01*x537))+((new_r11*x536)));
evalcond[5]=((1.0)+((new_r10*x536))+((new_r00*x537)));
evalcond[6]=((((-1.0)*new_r00*x538))+((new_r10*x537)));
evalcond[7]=((-1.0)+((new_r11*x537))+(((-1.0)*new_r01*x538)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x540 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x540)==0){
continue;
}
IkReal x539=pow(x540,-0.5);
CheckValue<IkReal> x541 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x541.valid){
continue;
}
IkReal gconst28=((-1.0)*(x541.value));
IkReal gconst29=((-1.0)*new_r01*x539);
IkReal gconst30=(new_r11*x539);
CheckValue<IkReal> x542 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x542.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((x542.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
CheckValue<IkReal> x545 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x545.valid){
continue;
}
IkReal x543=((-1.0)*(x545.value));
IkReal x544=x539;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x543;
IkReal gconst28=x543;
IkReal gconst29=((-1.0)*new_r01*x544);
IkReal gconst30=(new_r11*x544);
IkReal x546=new_r01*new_r01;
IkReal x547=(new_r00*new_r01);
IkReal x548=(((new_r10*new_r11))+x547);
IkReal x549=x539;
IkReal x550=(new_r01*x549);
j4eval[0]=x548;
j4eval[1]=((IKabs((((new_r10*x550))+(((-1.0)*x546*x549)))))+(IKabs((((new_r11*x550))+((x547*x549))))));
j4eval[2]=IKsign(x548);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
CheckValue<IkReal> x553 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x553.valid){
continue;
}
IkReal x551=((-1.0)*(x553.value));
IkReal x552=x539;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x551;
IkReal gconst28=x551;
IkReal gconst29=((-1.0)*new_r01*x552);
IkReal gconst30=(new_r11*x552);
IkReal x554=((new_r01*new_r01)+(new_r11*new_r11));
j4eval[0]=x554;
j4eval[1]=IKsign(x554);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x557 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x557.valid){
continue;
}
IkReal x555=((-1.0)*(x557.value));
IkReal x556=x539;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x555;
IkReal gconst28=x555;
IkReal gconst29=((-1.0)*new_r01*x556);
IkReal gconst30=(new_r11*x556);
j4eval[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((gconst29*gconst29)+(gconst30*gconst30));
evalcond[1]=new_r01;
evalcond[2]=new_r00;
evalcond[3]=new_r11;
evalcond[4]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[4], cj4array[4], sj4array[4];
bool j4valid[4]={false};
_nj4 = 4;
j4array[0]=0;
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=1.5707963267949;
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
j4array[2]=3.14159265358979;
sj4array[2]=IKsin(j4array[2]);
cj4array[2]=IKcos(j4array[2]);
j4array[3]=-1.5707963267949;
sj4array[3]=IKsin(j4array[3]);
cj4array[3]=IKcos(j4array[3]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
if( j4array[2] > IKPI )
{
    j4array[2]-=IK2PI;
}
else if( j4array[2] < -IKPI )
{    j4array[2]+=IK2PI;
}
j4valid[2] = true;
if( j4array[3] > IKPI )
{
    j4array[3]-=IK2PI;
}
else if( j4array[3] < -IKPI )
{    j4array[3]+=IK2PI;
}
j4valid[3] = true;
for(int ij4 = 0; ij4 < 4; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 4; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x559 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x559.valid){
continue;
}
IkReal x558=((-1.0)*(x559.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x558;
new_r11=0;
new_r00=0;
IkReal gconst28=x558;
IkReal x560 = new_r01*new_r01;
if(IKabs(x560)==0){
continue;
}
IkReal gconst29=((-1.0)*new_r01*(pow(x560,-0.5)));
IkReal gconst30=0;
j4eval[0]=new_r01;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x561=IKPowWithIntegerCheck(gconst29,-1);
if(!x561.valid){
continue;
}
cj4array[0]=((-1.0)*new_r01*(x561.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x562=IKsin(j4);
IkReal x563=IKcos(j4);
IkReal x564=((-1.0)*x562);
evalcond[0]=(new_r10*x562);
evalcond[1]=(gconst29*x564);
evalcond[2]=(new_r01*x564);
evalcond[3]=(gconst29+((new_r01*x563)));
evalcond[4]=(gconst29+((new_r10*x563)));
evalcond[5]=(((gconst29*x563))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x565=IKPowWithIntegerCheck(new_r01,-1);
if(!x565.valid){
continue;
}
cj4array[0]=((-1.0)*gconst29*(x565.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x566=IKsin(j4);
IkReal x567=IKcos(j4);
IkReal x568=(gconst29*x567);
IkReal x569=((-1.0)*x566);
evalcond[0]=(new_r10*x566);
evalcond[1]=(gconst29*x569);
evalcond[2]=(new_r01*x569);
evalcond[3]=(x568+new_r01);
evalcond[4]=(gconst29+((new_r10*x567)));
evalcond[5]=(x568+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst30;
evalcond[2]=gconst29;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
CheckValue<IkReal> x571 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x571.valid){
continue;
}
IkReal x570=((-1.0)*(x571.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x570;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst28=x570;
IkReal gconst29=((-1.0)*new_r01);
IkReal gconst30=new_r11;
j4eval[0]=-1.0;
j4eval[1]=((IKabs(new_r01*new_r01))+(IKabs((new_r01*new_r11))));
j4eval[2]=-1.0;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
CheckValue<IkReal> x573 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x573.valid){
continue;
}
IkReal x572=((-1.0)*(x573.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x572;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst28=x572;
IkReal gconst29=((-1.0)*new_r01);
IkReal gconst30=new_r11;
j4eval[0]=-1.0;
j4eval[1]=((IKabs((new_r01*new_r11)))+(IKabs(((1.0)+(((-1.0)*(new_r01*new_r01)))))));
j4eval[2]=-1.0;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
CheckValue<IkReal> x575 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x575.valid){
continue;
}
IkReal x574=((-1.0)*(x575.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x574;
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst28=x574;
IkReal gconst29=((-1.0)*new_r01);
IkReal gconst30=new_r11;
j4eval[0]=1.0;
j4eval[1]=((((0.5)*(IKabs(((-1.0)+(((2.0)*(new_r01*new_r01))))))))+(IKabs((new_r01*new_r11))));
j4eval[2]=1.0;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x576=((1.0)*gconst29);
CheckValue<IkReal> x577=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x577.valid){
continue;
}
CheckValue<IkReal> x578 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x576))+((gconst30*new_r01)))),IkReal(((((-1.0)*new_r01*x576))+(((-1.0)*gconst30*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x578.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x577.value)))+(x578.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x579=IKcos(j4);
IkReal x580=IKsin(j4);
IkReal x581=(gconst29*x579);
IkReal x582=(gconst30*x579);
IkReal x583=(gconst29*x580);
IkReal x584=((1.0)*x580);
IkReal x585=(gconst30*x584);
evalcond[0]=(((new_r01*x579))+gconst29+((new_r11*x580)));
evalcond[1]=(x582+x583+new_r11);
evalcond[2]=(x581+(((-1.0)*x585)));
evalcond[3]=(x581+new_r01+(((-1.0)*x585)));
evalcond[4]=((((-1.0)*x582))+(((-1.0)*x583)));
evalcond[5]=((((-1.0)*new_r01*x584))+((new_r11*x579))+gconst30);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x586 = IKatan2WithCheck(IkReal((gconst29*new_r11)),IkReal((gconst30*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x586.valid){
continue;
}
CheckValue<IkReal> x587=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst30*gconst30)))+(((-1.0)*(gconst29*gconst29))))),-1);
if(!x587.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x586.value)+(((1.5707963267949)*(x587.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x588=IKcos(j4);
IkReal x589=IKsin(j4);
IkReal x590=(gconst29*x588);
IkReal x591=(gconst30*x588);
IkReal x592=(gconst29*x589);
IkReal x593=((1.0)*x589);
IkReal x594=(gconst30*x593);
evalcond[0]=(gconst29+((new_r01*x588))+((new_r11*x589)));
evalcond[1]=(x592+x591+new_r11);
evalcond[2]=((((-1.0)*x594))+x590);
evalcond[3]=((((-1.0)*x594))+x590+new_r01);
evalcond[4]=((((-1.0)*x592))+(((-1.0)*x591)));
evalcond[5]=((((-1.0)*new_r01*x593))+gconst30+((new_r11*x588)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x595 = IKatan2WithCheck(IkReal((gconst29*gconst30)),IkReal(((-1.0)*(gconst29*gconst29))),IKFAST_ATAN2_MAGTHRESH);
if(!x595.valid){
continue;
}
CheckValue<IkReal> x596=IKPowWithIntegerCheck(IKsign((((gconst29*new_r01))+(((-1.0)*gconst30*new_r11)))),-1);
if(!x596.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x595.value)+(((1.5707963267949)*(x596.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x597=IKcos(j4);
IkReal x598=IKsin(j4);
IkReal x599=(gconst29*x597);
IkReal x600=(gconst30*x597);
IkReal x601=(gconst29*x598);
IkReal x602=((1.0)*x598);
IkReal x603=(gconst30*x602);
evalcond[0]=(((new_r11*x598))+gconst29+((new_r01*x597)));
evalcond[1]=(x601+x600+new_r11);
evalcond[2]=(x599+(((-1.0)*x603)));
evalcond[3]=(x599+(((-1.0)*x603))+new_r01);
evalcond[4]=((((-1.0)*x601))+(((-1.0)*x600)));
evalcond[5]=(((new_r11*x597))+gconst30+(((-1.0)*new_r01*x602)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x604=IKPowWithIntegerCheck(gconst30,-1);
if(!x604.valid){
continue;
}
cj4array[0]=(new_r00*(x604.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x605=IKsin(j4);
IkReal x606=IKcos(j4);
IkReal x607=((-1.0)*x605);
evalcond[0]=(new_r11*x605);
evalcond[1]=(gconst30*x607);
evalcond[2]=(new_r00*x607);
evalcond[3]=(((gconst30*x606))+new_r11);
evalcond[4]=(gconst30+((new_r11*x606)));
evalcond[5]=(((new_r00*x606))+(((-1.0)*gconst30)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x609 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x609.valid){
continue;
}
IkReal x608=((-1.0)*(x609.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x608;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst28=x608;
IkReal gconst29=0;
IkReal x610 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x610)==0){
continue;
}
IkReal gconst30=(new_r11*(pow(x610,-0.5)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x612 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x612.valid){
continue;
}
IkReal x611=((-1.0)*(x612.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x611;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst28=x611;
IkReal gconst29=0;
IkReal x613 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x613)==0){
continue;
}
IkReal gconst30=(new_r11*(pow(x613,-0.5)));
j4eval[0]=new_r11;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x615 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x615.valid){
continue;
}
IkReal x614=((-1.0)*(x615.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x614;
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst28=x614;
IkReal gconst29=0;
IkReal x616 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x616)==0){
continue;
}
IkReal gconst30=(new_r11*(pow(x616,-0.5)));
j4eval[0]=new_r10;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x617=IKPowWithIntegerCheck(new_r10,-1);
if(!x617.valid){
continue;
}
CheckValue<IkReal> x618=IKPowWithIntegerCheck(gconst30,-1);
if(!x618.valid){
continue;
}
if( IKabs((gconst30*(x617.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x618.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst30*(x617.value)))+IKsqr(((-1.0)*new_r11*(x618.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((gconst30*(x617.value)), ((-1.0)*new_r11*(x618.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x619=IKsin(j4);
IkReal x620=IKcos(j4);
IkReal x621=((1.0)*gconst30);
IkReal x622=(gconst30*x620);
evalcond[0]=(new_r11*x619);
evalcond[1]=(new_r10*x620);
evalcond[2]=((-1.0)*gconst30*x619);
evalcond[3]=((-1.0)*x622);
evalcond[4]=(x622+new_r11);
evalcond[5]=(gconst30+((new_r11*x620)));
evalcond[6]=((((-1.0)*x619*x621))+new_r10);
evalcond[7]=((((-1.0)*x621))+((new_r10*x619)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x623=IKPowWithIntegerCheck(gconst30,-1);
if(!x623.valid){
continue;
}
CheckValue<IkReal> x624=IKPowWithIntegerCheck(new_r11,-1);
if(!x624.valid){
continue;
}
if( IKabs((new_r10*(x623.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst30*(x624.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x623.value)))+IKsqr(((-1.0)*gconst30*(x624.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r10*(x623.value)), ((-1.0)*gconst30*(x624.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x625=IKsin(j4);
IkReal x626=IKcos(j4);
IkReal x627=((1.0)*gconst30);
IkReal x628=(gconst30*x626);
evalcond[0]=(new_r11*x625);
evalcond[1]=(new_r10*x626);
evalcond[2]=((-1.0)*gconst30*x625);
evalcond[3]=((-1.0)*x628);
evalcond[4]=(x628+new_r11);
evalcond[5]=(gconst30+((new_r11*x626)));
evalcond[6]=((((-1.0)*x625*x627))+new_r10);
evalcond[7]=((((-1.0)*x627))+((new_r10*x625)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x629=IKPowWithIntegerCheck(IKsign(gconst30),-1);
if(!x629.valid){
continue;
}
CheckValue<IkReal> x630 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x630.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x629.value)))+(x630.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x631=IKsin(j4);
IkReal x632=IKcos(j4);
IkReal x633=((1.0)*gconst30);
IkReal x634=(gconst30*x632);
evalcond[0]=(new_r11*x631);
evalcond[1]=(new_r10*x632);
evalcond[2]=((-1.0)*gconst30*x631);
evalcond[3]=((-1.0)*x634);
evalcond[4]=(x634+new_r11);
evalcond[5]=(gconst30+((new_r11*x632)));
evalcond[6]=((((-1.0)*x631*x633))+new_r10);
evalcond[7]=((((-1.0)*x633))+((new_r10*x631)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x636 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x636.valid){
continue;
}
IkReal x635=((-1.0)*(x636.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x635;
new_r01=0;
IkReal gconst28=x635;
IkReal gconst29=0;
IkReal x637 = new_r11*new_r11;
if(IKabs(x637)==0){
continue;
}
IkReal gconst30=(new_r11*(pow(x637,-0.5)));
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x639 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x639.valid){
continue;
}
IkReal x638=((-1.0)*(x639.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x638;
new_r01=0;
IkReal gconst28=x638;
IkReal gconst29=0;
IkReal x640 = new_r11*new_r11;
if(IKabs(x640)==0){
continue;
}
IkReal gconst30=(new_r11*(pow(x640,-0.5)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x642 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x642.valid){
continue;
}
IkReal x641=((-1.0)*(x642.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst29;
cj6=gconst30;
j6=x641;
new_r01=0;
IkReal gconst28=x641;
IkReal gconst29=0;
IkReal x643 = new_r11*new_r11;
if(IKabs(x643)==0){
continue;
}
IkReal gconst30=(new_r11*(pow(x643,-0.5)));
j4eval[0]=new_r11;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x644=IKPowWithIntegerCheck(gconst30,-1);
if(!x644.valid){
continue;
}
CheckValue<IkReal> x645=IKPowWithIntegerCheck(new_r11,-1);
if(!x645.valid){
continue;
}
if( IKabs((new_r10*(x644.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst30*(x645.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x644.value)))+IKsqr(((-1.0)*gconst30*(x645.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r10*(x644.value)), ((-1.0)*gconst30*(x645.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x646=IKsin(j4);
IkReal x647=IKcos(j4);
IkReal x648=((1.0)*gconst30);
IkReal x649=(gconst30*x647);
evalcond[0]=(new_r11*x646);
evalcond[1]=((-1.0)*gconst30*x646);
evalcond[2]=(x649+new_r11);
evalcond[3]=(gconst30+((new_r11*x647)));
evalcond[4]=((((-1.0)*x647*x648))+new_r00);
evalcond[5]=((((-1.0)*x646*x648))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x646))+((new_r10*x647)));
evalcond[7]=((((-1.0)*x648))+((new_r10*x646))+((new_r00*x647)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x650=IKPowWithIntegerCheck(IKsign(gconst30),-1);
if(!x650.valid){
continue;
}
CheckValue<IkReal> x651 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x651.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x650.value)))+(x651.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x652=IKsin(j4);
IkReal x653=IKcos(j4);
IkReal x654=((1.0)*gconst30);
IkReal x655=(gconst30*x653);
evalcond[0]=(new_r11*x652);
evalcond[1]=((-1.0)*gconst30*x652);
evalcond[2]=(x655+new_r11);
evalcond[3]=(gconst30+((new_r11*x653)));
evalcond[4]=(new_r00+(((-1.0)*x653*x654)));
evalcond[5]=(new_r10+(((-1.0)*x652*x654)));
evalcond[6]=((((-1.0)*new_r00*x652))+((new_r10*x653)));
evalcond[7]=((((-1.0)*x654))+((new_r10*x652))+((new_r00*x653)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x656=IKPowWithIntegerCheck(IKsign(gconst30),-1);
if(!x656.valid){
continue;
}
CheckValue<IkReal> x657 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x657.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x656.value)))+(x657.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x658=IKsin(j4);
IkReal x659=IKcos(j4);
IkReal x660=((1.0)*gconst30);
IkReal x661=(gconst30*x659);
evalcond[0]=(new_r11*x658);
evalcond[1]=((-1.0)*gconst30*x658);
evalcond[2]=(x661+new_r11);
evalcond[3]=(gconst30+((new_r11*x659)));
evalcond[4]=((((-1.0)*x659*x660))+new_r00);
evalcond[5]=((((-1.0)*x658*x660))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x658))+((new_r10*x659)));
evalcond[7]=((((-1.0)*x660))+((new_r10*x658))+((new_r00*x659)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x662=((1.0)*gconst29);
CheckValue<IkReal> x663 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x662))+((gconst30*new_r01)))),IkReal(((((-1.0)*gconst30*new_r11))+(((-1.0)*new_r01*x662)))),IKFAST_ATAN2_MAGTHRESH);
if(!x663.valid){
continue;
}
CheckValue<IkReal> x664=IKPowWithIntegerCheck(IKsign(((gconst29*gconst29)+(gconst30*gconst30))),-1);
if(!x664.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x663.value)+(((1.5707963267949)*(x664.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x665=IKcos(j4);
IkReal x666=IKsin(j4);
IkReal x667=((1.0)*gconst30);
IkReal x668=(gconst29*x665);
IkReal x669=(gconst30*x665);
IkReal x670=(gconst29*x666);
IkReal x671=((1.0)*x666);
IkReal x672=(x666*x667);
evalcond[0]=(gconst29+((new_r11*x666))+((new_r01*x665)));
evalcond[1]=(x669+x670+new_r11);
evalcond[2]=(x668+new_r01+(((-1.0)*x672)));
evalcond[3]=((((-1.0)*new_r00*x671))+gconst29+((new_r10*x665)));
evalcond[4]=((((-1.0)*new_r01*x671))+gconst30+((new_r11*x665)));
evalcond[5]=(x668+new_r10+(((-1.0)*x672)));
evalcond[6]=(((new_r10*x666))+(((-1.0)*x667))+((new_r00*x665)));
evalcond[7]=((((-1.0)*x665*x667))+(((-1.0)*x670))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x673=((1.0)*gconst29);
CheckValue<IkReal> x674=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x674.valid){
continue;
}
CheckValue<IkReal> x675 = IKatan2WithCheck(IkReal((((gconst30*new_r01))+(((-1.0)*new_r11*x673)))),IkReal(((((-1.0)*new_r01*x673))+(((-1.0)*gconst30*new_r11)))),IKFAST_ATAN2_MAGTHRESH);
if(!x675.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x674.value)))+(x675.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x676=IKcos(j4);
IkReal x677=IKsin(j4);
IkReal x678=((1.0)*gconst30);
IkReal x679=(gconst29*x676);
IkReal x680=(gconst30*x676);
IkReal x681=(gconst29*x677);
IkReal x682=((1.0)*x677);
IkReal x683=(x677*x678);
evalcond[0]=(((new_r11*x677))+((new_r01*x676))+gconst29);
evalcond[1]=(x681+x680+new_r11);
evalcond[2]=((((-1.0)*x683))+x679+new_r01);
evalcond[3]=(((new_r10*x676))+gconst29+(((-1.0)*new_r00*x682)));
evalcond[4]=(((new_r11*x676))+(((-1.0)*new_r01*x682))+gconst30);
evalcond[5]=((((-1.0)*x683))+x679+new_r10);
evalcond[6]=(((new_r00*x676))+((new_r10*x677))+(((-1.0)*x678)));
evalcond[7]=((((-1.0)*x676*x678))+new_r00+(((-1.0)*x681)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x684=((1.0)*gconst29);
CheckValue<IkReal> x685 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x684))+((gconst29*new_r01)))),IkReal(((((-1.0)*new_r11*x684))+(((-1.0)*new_r00*x684)))),IKFAST_ATAN2_MAGTHRESH);
if(!x685.valid){
continue;
}
CheckValue<IkReal> x686=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x686.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x685.value)+(((1.5707963267949)*(x686.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x687=IKcos(j4);
IkReal x688=IKsin(j4);
IkReal x689=((1.0)*gconst30);
IkReal x690=(gconst29*x687);
IkReal x691=(gconst30*x687);
IkReal x692=(gconst29*x688);
IkReal x693=((1.0)*x688);
IkReal x694=(x688*x689);
evalcond[0]=(gconst29+((new_r01*x687))+((new_r11*x688)));
evalcond[1]=(x691+x692+new_r11);
evalcond[2]=(x690+(((-1.0)*x694))+new_r01);
evalcond[3]=(gconst29+(((-1.0)*new_r00*x693))+((new_r10*x687)));
evalcond[4]=((((-1.0)*new_r01*x693))+gconst30+((new_r11*x687)));
evalcond[5]=(x690+(((-1.0)*x694))+new_r10);
evalcond[6]=((((-1.0)*x689))+((new_r00*x687))+((new_r10*x688)));
evalcond[7]=((((-1.0)*x687*x689))+new_r00+(((-1.0)*x692)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
IkReal x696 = ((new_r01*new_r01)+(new_r11*new_r11));
if(IKabs(x696)==0){
continue;
}
IkReal x695=pow(x696,-0.5);
CheckValue<IkReal> x697 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x697.valid){
continue;
}
IkReal gconst31=((3.14159265358979)+(((-1.0)*(x697.value))));
IkReal gconst32=((1.0)*new_r01*x695);
IkReal gconst33=((-1.0)*new_r11*x695);
CheckValue<IkReal> x698 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x698.valid){
continue;
}
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+(x698.value)+j6)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[3];
CheckValue<IkReal> x701 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x701.valid){
continue;
}
IkReal x699=((1.0)*(x701.value));
IkReal x700=x695;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x699)));
IkReal gconst31=((3.14159265358979)+(((-1.0)*x699)));
IkReal gconst32=((1.0)*new_r01*x700);
IkReal gconst33=((-1.0)*new_r11*x700);
IkReal x702=new_r01*new_r01;
IkReal x703=(((new_r10*new_r11))+((new_r00*new_r01)));
IkReal x704=x695;
IkReal x705=((1.0)*new_r01*x704);
j4eval[0]=x703;
j4eval[1]=IKsign(x703);
j4eval[2]=((IKabs((((x702*x704))+(((-1.0)*new_r10*x705)))))+(IKabs(((((-1.0)*new_r11*x705))+(((-1.0)*new_r00*x705))))));
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
CheckValue<IkReal> x708 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x708.valid){
continue;
}
IkReal x706=((1.0)*(x708.value));
IkReal x707=x695;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x706)));
IkReal gconst31=((3.14159265358979)+(((-1.0)*x706)));
IkReal gconst32=((1.0)*new_r01*x707);
IkReal gconst33=((-1.0)*new_r11*x707);
IkReal x709=((new_r01*new_r01)+(new_r11*new_r11));
j4eval[0]=x709;
j4eval[1]=IKsign(x709);
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x712 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x712.valid){
continue;
}
IkReal x710=((1.0)*(x712.value));
IkReal x711=x695;
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x710)));
IkReal gconst31=((3.14159265358979)+(((-1.0)*x710)));
IkReal gconst32=((1.0)*new_r01*x711);
IkReal gconst33=((-1.0)*new_r11*x711);
j4eval[0]=((new_r01*new_r01)+(new_r11*new_r11));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((gconst32*gconst32)+(gconst33*gconst33));
evalcond[1]=new_r01;
evalcond[2]=new_r00;
evalcond[3]=new_r11;
evalcond[4]=new_r10;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[4], cj4array[4], sj4array[4];
bool j4valid[4]={false};
_nj4 = 4;
j4array[0]=0;
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=1.5707963267949;
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
j4array[2]=3.14159265358979;
sj4array[2]=IKsin(j4array[2]);
cj4array[2]=IKcos(j4array[2]);
j4array[3]=-1.5707963267949;
sj4array[3]=IKsin(j4array[3]);
cj4array[3]=IKcos(j4array[3]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
if( j4array[2] > IKPI )
{
    j4array[2]-=IK2PI;
}
else if( j4array[2] < -IKPI )
{    j4array[2]+=IK2PI;
}
j4valid[2] = true;
if( j4array[3] > IKPI )
{
    j4array[3]-=IK2PI;
}
else if( j4array[3] < -IKPI )
{    j4array[3]+=IK2PI;
}
j4valid[3] = true;
for(int ij4 = 0; ij4 < 4; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 4; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r00)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x714 = IKatan2WithCheck(IkReal(new_r01),IkReal(0),IKFAST_ATAN2_MAGTHRESH);
if(!x714.valid){
continue;
}
IkReal x713=((1.0)*(x714.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x713)));
new_r11=0;
new_r00=0;
IkReal gconst31=((3.14159265358979)+(((-1.0)*x713)));
IkReal x715 = new_r01*new_r01;
if(IKabs(x715)==0){
continue;
}
IkReal gconst32=((1.0)*new_r01*(pow(x715,-0.5)));
IkReal gconst33=0;
j4eval[0]=new_r01;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x716=IKPowWithIntegerCheck(gconst32,-1);
if(!x716.valid){
continue;
}
cj4array[0]=((-1.0)*new_r01*(x716.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x717=IKsin(j4);
IkReal x718=IKcos(j4);
IkReal x719=((-1.0)*x717);
evalcond[0]=(new_r10*x717);
evalcond[1]=(gconst32*x719);
evalcond[2]=(new_r01*x719);
evalcond[3]=(((new_r01*x718))+gconst32);
evalcond[4]=(gconst32+((new_r10*x718)));
evalcond[5]=(new_r10+((gconst32*x718)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x720=IKPowWithIntegerCheck(new_r01,-1);
if(!x720.valid){
continue;
}
cj4array[0]=((-1.0)*gconst32*(x720.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x721=IKsin(j4);
IkReal x722=IKcos(j4);
IkReal x723=(gconst32*x722);
IkReal x724=((-1.0)*x721);
evalcond[0]=(new_r10*x721);
evalcond[1]=(gconst32*x724);
evalcond[2]=(new_r01*x724);
evalcond[3]=(x723+new_r01);
evalcond[4]=(gconst32+((new_r10*x722)));
evalcond[5]=(x723+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r00)));
evalcond[1]=gconst33;
evalcond[2]=gconst32;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[4];
CheckValue<IkReal> x726 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x726.valid){
continue;
}
IkReal x725=((1.0)*(x726.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x725)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst31=((3.14159265358979)+(((-1.0)*x725)));
IkReal gconst32=((1.0)*new_r01);
IkReal gconst33=((-1.0)*new_r11);
j4eval[0]=1.0;
j4eval[1]=1.0;
j4eval[2]=new_r01;
j4eval[3]=1.0;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  || IKabs(j4eval[3]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
CheckValue<IkReal> x728 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x728.valid){
continue;
}
IkReal x727=((1.0)*(x728.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x727)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst31=((3.14159265358979)+(((-1.0)*x727)));
IkReal gconst32=((1.0)*new_r01);
IkReal gconst33=((-1.0)*new_r11);
j4eval[0]=-1.0;
j4eval[1]=((IKabs(((-1.0)+(new_r01*new_r01))))+(IKabs(((1.0)*new_r01*new_r11))));
j4eval[2]=-1.0;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
{
IkReal j4eval[3];
CheckValue<IkReal> x730 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x730.valid){
continue;
}
IkReal x729=((1.0)*(x730.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x729)));
new_r00=0;
new_r10=0;
new_r21=0;
new_r22=0;
IkReal gconst31=((3.14159265358979)+(((-1.0)*x729)));
IkReal gconst32=((1.0)*new_r01);
IkReal gconst33=((-1.0)*new_r11);
j4eval[0]=1.0;
j4eval[1]=((IKabs(((2.0)*new_r01*new_r11)))+(IKabs(((1.0)+(((-2.0)*(new_r01*new_r01)))))));
j4eval[2]=1.0;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  || IKabs(j4eval[2]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x731=((1.0)*new_r11);
CheckValue<IkReal> x732 = IKatan2WithCheck(IkReal(((((-1.0)*gconst32*x731))+((gconst33*new_r01)))),IkReal(((((-1.0)*gconst32*new_r01))+(((-1.0)*gconst33*x731)))),IKFAST_ATAN2_MAGTHRESH);
if(!x732.valid){
continue;
}
CheckValue<IkReal> x733=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x733.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x732.value)+(((1.5707963267949)*(x733.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x734=IKcos(j4);
IkReal x735=IKsin(j4);
IkReal x736=((1.0)*gconst33);
IkReal x737=(gconst32*x734);
IkReal x738=(gconst32*x735);
IkReal x739=(x735*x736);
evalcond[0]=(((new_r01*x734))+gconst32+((new_r11*x735)));
evalcond[1]=(((gconst33*x734))+x738+new_r11);
evalcond[2]=((((-1.0)*x739))+x737);
evalcond[3]=((((-1.0)*x739))+x737+new_r01);
evalcond[4]=((((-1.0)*x734*x736))+(((-1.0)*x738)));
evalcond[5]=(gconst33+(((-1.0)*new_r01*x735))+((new_r11*x734)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x740=IKPowWithIntegerCheck(IKsign(((((-1.0)*(gconst32*gconst32)))+(((-1.0)*(gconst33*gconst33))))),-1);
if(!x740.valid){
continue;
}
CheckValue<IkReal> x741 = IKatan2WithCheck(IkReal((gconst32*new_r11)),IkReal((gconst33*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x741.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x740.value)))+(x741.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x742=IKcos(j4);
IkReal x743=IKsin(j4);
IkReal x744=((1.0)*gconst33);
IkReal x745=(gconst32*x742);
IkReal x746=(gconst32*x743);
IkReal x747=(x743*x744);
evalcond[0]=(gconst32+((new_r01*x742))+((new_r11*x743)));
evalcond[1]=(x746+((gconst33*x742))+new_r11);
evalcond[2]=(x745+(((-1.0)*x747)));
evalcond[3]=(x745+new_r01+(((-1.0)*x747)));
evalcond[4]=((((-1.0)*x742*x744))+(((-1.0)*x746)));
evalcond[5]=(gconst33+((new_r11*x742))+(((-1.0)*new_r01*x743)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x748=IKPowWithIntegerCheck(IKsign(((((-1.0)*gconst33*new_r11))+((gconst32*new_r01)))),-1);
if(!x748.valid){
continue;
}
CheckValue<IkReal> x749 = IKatan2WithCheck(IkReal((gconst32*gconst33)),IkReal(((-1.0)*(gconst32*gconst32))),IKFAST_ATAN2_MAGTHRESH);
if(!x749.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x748.value)))+(x749.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x750=IKcos(j4);
IkReal x751=IKsin(j4);
IkReal x752=((1.0)*gconst33);
IkReal x753=(gconst32*x750);
IkReal x754=(gconst32*x751);
IkReal x755=(x751*x752);
evalcond[0]=(gconst32+((new_r11*x751))+((new_r01*x750)));
evalcond[1]=(((gconst33*x750))+x754+new_r11);
evalcond[2]=(x753+(((-1.0)*x755)));
evalcond[3]=(x753+new_r01+(((-1.0)*x755)));
evalcond[4]=((((-1.0)*x750*x752))+(((-1.0)*x754)));
evalcond[5]=(gconst33+((new_r11*x750))+(((-1.0)*new_r01*x751)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r10))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x756=IKPowWithIntegerCheck(gconst33,-1);
if(!x756.valid){
continue;
}
cj4array[0]=(new_r00*(x756.value));
if( cj4array[0] >= -1-IKFAST_SINCOS_THRESH && cj4array[0] <= 1+IKFAST_SINCOS_THRESH )
{
    j4valid[0] = j4valid[1] = true;
    j4array[0] = IKacos(cj4array[0]);
    sj4array[0] = IKsin(j4array[0]);
    cj4array[1] = cj4array[0];
    j4array[1] = -j4array[0];
    sj4array[1] = -sj4array[0];
}
else if( isnan(cj4array[0]) )
{
    // probably any value will work
    j4valid[0] = true;
    cj4array[0] = 1; sj4array[0] = 0; j4array[0] = 0;
}
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[6];
IkReal x757=IKsin(j4);
IkReal x758=IKcos(j4);
IkReal x759=((-1.0)*x757);
evalcond[0]=(new_r11*x757);
evalcond[1]=(gconst33*x759);
evalcond[2]=(new_r00*x759);
evalcond[3]=(((gconst33*x758))+new_r11);
evalcond[4]=(gconst33+((new_r11*x758)));
evalcond[5]=(((new_r00*x758))+(((-1.0)*gconst33)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r00))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x761 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x761.valid){
continue;
}
IkReal x760=((1.0)*(x761.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x760)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst31=((3.14159265358979)+(((-1.0)*x760)));
IkReal gconst32=0;
IkReal x762 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x762)==0){
continue;
}
IkReal gconst33=((-1.0)*new_r11*(pow(x762,-0.5)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x764 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x764.valid){
continue;
}
IkReal x763=((1.0)*(x764.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x763)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst31=((3.14159265358979)+(((-1.0)*x763)));
IkReal gconst32=0;
IkReal x765 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x765)==0){
continue;
}
IkReal gconst33=((-1.0)*new_r11*(pow(x765,-0.5)));
j4eval[0]=new_r11;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x767 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x767.valid){
continue;
}
IkReal x766=((1.0)*(x767.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x766)));
new_r00=0;
new_r01=0;
new_r12=0;
new_r22=0;
IkReal gconst31=((3.14159265358979)+(((-1.0)*x766)));
IkReal gconst32=0;
IkReal x768 = ((1.0)+(((-1.0)*(new_r10*new_r10))));
if(IKabs(x768)==0){
continue;
}
IkReal gconst33=((-1.0)*new_r11*(pow(x768,-0.5)));
j4eval[0]=new_r10;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x769=IKPowWithIntegerCheck(new_r10,-1);
if(!x769.valid){
continue;
}
CheckValue<IkReal> x770=IKPowWithIntegerCheck(gconst33,-1);
if(!x770.valid){
continue;
}
if( IKabs((gconst33*(x769.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r11*(x770.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((gconst33*(x769.value)))+IKsqr(((-1.0)*new_r11*(x770.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((gconst33*(x769.value)), ((-1.0)*new_r11*(x770.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x771=IKsin(j4);
IkReal x772=IKcos(j4);
IkReal x773=((1.0)*gconst33);
IkReal x774=((-1.0)*gconst33);
evalcond[0]=(new_r11*x771);
evalcond[1]=(new_r10*x772);
evalcond[2]=(x771*x774);
evalcond[3]=(x772*x774);
evalcond[4]=(((gconst33*x772))+new_r11);
evalcond[5]=(gconst33+((new_r11*x772)));
evalcond[6]=((((-1.0)*x771*x773))+new_r10);
evalcond[7]=(((new_r10*x771))+(((-1.0)*x773)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x775=IKPowWithIntegerCheck(gconst33,-1);
if(!x775.valid){
continue;
}
CheckValue<IkReal> x776=IKPowWithIntegerCheck(new_r11,-1);
if(!x776.valid){
continue;
}
if( IKabs((new_r10*(x775.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst33*(x776.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x775.value)))+IKsqr(((-1.0)*gconst33*(x776.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r10*(x775.value)), ((-1.0)*gconst33*(x776.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x777=IKsin(j4);
IkReal x778=IKcos(j4);
IkReal x779=((1.0)*gconst33);
IkReal x780=((-1.0)*gconst33);
evalcond[0]=(new_r11*x777);
evalcond[1]=(new_r10*x778);
evalcond[2]=(x777*x780);
evalcond[3]=(x778*x780);
evalcond[4]=(((gconst33*x778))+new_r11);
evalcond[5]=(gconst33+((new_r11*x778)));
evalcond[6]=(new_r10+(((-1.0)*x777*x779)));
evalcond[7]=(((new_r10*x777))+(((-1.0)*x779)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x781 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x781.valid){
continue;
}
CheckValue<IkReal> x782=IKPowWithIntegerCheck(IKsign(gconst33),-1);
if(!x782.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x781.value)+(((1.5707963267949)*(x782.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x783=IKsin(j4);
IkReal x784=IKcos(j4);
IkReal x785=((1.0)*gconst33);
IkReal x786=((-1.0)*gconst33);
evalcond[0]=(new_r11*x783);
evalcond[1]=(new_r10*x784);
evalcond[2]=(x783*x786);
evalcond[3]=(x784*x786);
evalcond[4]=(((gconst33*x784))+new_r11);
evalcond[5]=(((new_r11*x784))+gconst33);
evalcond[6]=(new_r10+(((-1.0)*x783*x785)));
evalcond[7]=(((new_r10*x783))+(((-1.0)*x785)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r01);
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
CheckValue<IkReal> x788 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x788.valid){
continue;
}
IkReal x787=((1.0)*(x788.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x787)));
new_r01=0;
IkReal gconst31=((3.14159265358979)+(((-1.0)*x787)));
IkReal gconst32=0;
IkReal x789 = new_r11*new_r11;
if(IKabs(x789)==0){
continue;
}
IkReal gconst33=((-1.0)*new_r11*(pow(x789,-0.5)));
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x791 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x791.valid){
continue;
}
IkReal x790=((1.0)*(x791.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x790)));
new_r01=0;
IkReal gconst31=((3.14159265358979)+(((-1.0)*x790)));
IkReal gconst32=0;
IkReal x792 = new_r11*new_r11;
if(IKabs(x792)==0){
continue;
}
IkReal gconst33=((-1.0)*new_r11*(pow(x792,-0.5)));
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r10)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
CheckValue<IkReal> x794 = IKatan2WithCheck(IkReal(0),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x794.valid){
continue;
}
IkReal x793=((1.0)*(x794.value));
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
sj6=gconst32;
cj6=gconst33;
j6=((3.14159265)+(((-1.0)*x793)));
new_r01=0;
IkReal gconst31=((3.14159265358979)+(((-1.0)*x793)));
IkReal gconst32=0;
IkReal x795 = new_r11*new_r11;
if(IKabs(x795)==0){
continue;
}
IkReal gconst33=((-1.0)*new_r11*(pow(x795,-0.5)));
j4eval[0]=new_r11;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // 3 cases reached

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x796=IKPowWithIntegerCheck(gconst33,-1);
if(!x796.valid){
continue;
}
CheckValue<IkReal> x797=IKPowWithIntegerCheck(new_r11,-1);
if(!x797.valid){
continue;
}
if( IKabs((new_r10*(x796.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*gconst33*(x797.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((new_r10*(x796.value)))+IKsqr(((-1.0)*gconst33*(x797.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((new_r10*(x796.value)), ((-1.0)*gconst33*(x797.value)));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x798=IKsin(j4);
IkReal x799=IKcos(j4);
IkReal x800=((1.0)*gconst33);
evalcond[0]=(new_r11*x798);
evalcond[1]=((-1.0)*gconst33*x798);
evalcond[2]=(((gconst33*x799))+new_r11);
evalcond[3]=(((new_r11*x799))+gconst33);
evalcond[4]=((((-1.0)*x799*x800))+new_r00);
evalcond[5]=((((-1.0)*x798*x800))+new_r10);
evalcond[6]=(((new_r10*x799))+(((-1.0)*new_r00*x798)));
evalcond[7]=(((new_r10*x798))+((new_r00*x799))+(((-1.0)*x800)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x801 = IKatan2WithCheck(IkReal(new_r10),IkReal(((-1.0)*new_r11)),IKFAST_ATAN2_MAGTHRESH);
if(!x801.valid){
continue;
}
CheckValue<IkReal> x802=IKPowWithIntegerCheck(IKsign(gconst33),-1);
if(!x802.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x801.value)+(((1.5707963267949)*(x802.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x803=IKsin(j4);
IkReal x804=IKcos(j4);
IkReal x805=((1.0)*gconst33);
evalcond[0]=(new_r11*x803);
evalcond[1]=((-1.0)*gconst33*x803);
evalcond[2]=(((gconst33*x804))+new_r11);
evalcond[3]=(gconst33+((new_r11*x804)));
evalcond[4]=((((-1.0)*x804*x805))+new_r00);
evalcond[5]=((((-1.0)*x803*x805))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x803))+((new_r10*x804)));
evalcond[7]=(((new_r00*x804))+((new_r10*x803))+(((-1.0)*x805)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x806 = IKatan2WithCheck(IkReal(new_r10),IkReal(new_r00),IKFAST_ATAN2_MAGTHRESH);
if(!x806.valid){
continue;
}
CheckValue<IkReal> x807=IKPowWithIntegerCheck(IKsign(gconst33),-1);
if(!x807.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x806.value)+(((1.5707963267949)*(x807.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x808=IKsin(j4);
IkReal x809=IKcos(j4);
IkReal x810=((1.0)*gconst33);
evalcond[0]=(new_r11*x808);
evalcond[1]=((-1.0)*gconst33*x808);
evalcond[2]=(((gconst33*x809))+new_r11);
evalcond[3]=(gconst33+((new_r11*x809)));
evalcond[4]=((((-1.0)*x809*x810))+new_r00);
evalcond[5]=((((-1.0)*x808*x810))+new_r10);
evalcond[6]=((((-1.0)*new_r00*x808))+((new_r10*x809)));
evalcond[7]=((((-1.0)*x810))+((new_r00*x809))+((new_r10*x808)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x811=((1.0)*new_r11);
CheckValue<IkReal> x812 = IKatan2WithCheck(IkReal((((gconst33*new_r01))+(((-1.0)*gconst32*x811)))),IkReal(((((-1.0)*gconst33*x811))+(((-1.0)*gconst32*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x812.valid){
continue;
}
CheckValue<IkReal> x813=IKPowWithIntegerCheck(IKsign(((gconst32*gconst32)+(gconst33*gconst33))),-1);
if(!x813.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x812.value)+(((1.5707963267949)*(x813.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x814=IKcos(j4);
IkReal x815=IKsin(j4);
IkReal x816=((1.0)*gconst33);
IkReal x817=(gconst32*x814);
IkReal x818=(gconst32*x815);
IkReal x819=((1.0)*x815);
IkReal x820=(x815*x816);
evalcond[0]=(((new_r11*x815))+((new_r01*x814))+gconst32);
evalcond[1]=(((gconst33*x814))+new_r11+x818);
evalcond[2]=((((-1.0)*x820))+new_r01+x817);
evalcond[3]=(((new_r10*x814))+gconst32+(((-1.0)*new_r00*x819)));
evalcond[4]=(((new_r11*x814))+gconst33+(((-1.0)*new_r01*x819)));
evalcond[5]=((((-1.0)*x820))+new_r10+x817);
evalcond[6]=(((new_r00*x814))+((new_r10*x815))+(((-1.0)*x816)));
evalcond[7]=((((-1.0)*x814*x816))+(((-1.0)*x818))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x821=((1.0)*new_r11);
CheckValue<IkReal> x822=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x822.valid){
continue;
}
CheckValue<IkReal> x823 = IKatan2WithCheck(IkReal((((gconst33*new_r01))+(((-1.0)*gconst32*x821)))),IkReal(((((-1.0)*gconst33*x821))+(((-1.0)*gconst32*new_r01)))),IKFAST_ATAN2_MAGTHRESH);
if(!x823.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x822.value)))+(x823.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x824=IKcos(j4);
IkReal x825=IKsin(j4);
IkReal x826=((1.0)*gconst33);
IkReal x827=(gconst32*x824);
IkReal x828=(gconst32*x825);
IkReal x829=((1.0)*x825);
IkReal x830=(x825*x826);
evalcond[0]=(((new_r01*x824))+gconst32+((new_r11*x825)));
evalcond[1]=(new_r11+x828+((gconst33*x824)));
evalcond[2]=((((-1.0)*x830))+new_r01+x827);
evalcond[3]=(((new_r10*x824))+gconst32+(((-1.0)*new_r00*x829)));
evalcond[4]=(gconst33+((new_r11*x824))+(((-1.0)*new_r01*x829)));
evalcond[5]=((((-1.0)*x830))+new_r10+x827);
evalcond[6]=(((new_r10*x825))+(((-1.0)*x826))+((new_r00*x824)));
evalcond[7]=((((-1.0)*x824*x826))+(((-1.0)*x828))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x831=((1.0)*gconst32);
CheckValue<IkReal> x832 = IKatan2WithCheck(IkReal(((((-1.0)*new_r10*x831))+((gconst32*new_r01)))),IkReal(((((-1.0)*new_r11*x831))+(((-1.0)*new_r00*x831)))),IKFAST_ATAN2_MAGTHRESH);
if(!x832.valid){
continue;
}
CheckValue<IkReal> x833=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x833.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x832.value)+(((1.5707963267949)*(x833.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x834=IKcos(j4);
IkReal x835=IKsin(j4);
IkReal x836=((1.0)*gconst33);
IkReal x837=(gconst32*x834);
IkReal x838=(gconst32*x835);
IkReal x839=((1.0)*x835);
IkReal x840=(x835*x836);
evalcond[0]=(((new_r11*x835))+((new_r01*x834))+gconst32);
evalcond[1]=(new_r11+x838+((gconst33*x834)));
evalcond[2]=((((-1.0)*x840))+new_r01+x837);
evalcond[3]=(gconst32+(((-1.0)*new_r00*x839))+((new_r10*x834)));
evalcond[4]=(((new_r11*x834))+gconst33+(((-1.0)*new_r01*x839)));
evalcond[5]=((((-1.0)*x840))+new_r10+x837);
evalcond[6]=(((new_r00*x834))+(((-1.0)*x836))+((new_r10*x835)));
evalcond[7]=((((-1.0)*x834*x836))+(((-1.0)*x838))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj5=0;
cj5=-1.0;
j5=3.14159265358979;
new_r11=0;
new_r01=0;
new_r22=0;
new_r20=0;
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x842 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x842.valid){
continue;
}
IkReal x841=x842.value;
j4array[0]=((-1.0)*x841);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x841)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[1];
evalcond[0]=(((new_r10*(IKcos(j4))))+(((-1.0)*new_r00*(IKsin(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x843=((1.0)*sj6);
CheckValue<IkReal> x844=IKPowWithIntegerCheck(IKsign(((new_r01*new_r01)+(new_r11*new_r11))),-1);
if(!x844.valid){
continue;
}
CheckValue<IkReal> x845 = IKatan2WithCheck(IkReal(((((-1.0)*new_r11*x843))+((cj6*new_r01)))),IkReal(((((-1.0)*cj6*new_r11))+(((-1.0)*new_r01*x843)))),IKFAST_ATAN2_MAGTHRESH);
if(!x845.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x844.value)))+(x845.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x846=IKsin(j4);
IkReal x847=IKcos(j4);
IkReal x848=((1.0)*cj6);
IkReal x849=(sj6*x847);
IkReal x850=(sj6*x846);
IkReal x851=((1.0)*x846);
IkReal x852=(x846*x848);
evalcond[0]=(sj6+((new_r01*x847))+((new_r11*x846)));
evalcond[1]=(((cj6*x847))+new_r11+x850);
evalcond[2]=((((-1.0)*x852))+new_r01+x849);
evalcond[3]=(((new_r10*x847))+sj6+(((-1.0)*new_r00*x851)));
evalcond[4]=(cj6+(((-1.0)*new_r01*x851))+((new_r11*x847)));
evalcond[5]=((((-1.0)*x852))+new_r10+x849);
evalcond[6]=(((new_r10*x846))+((new_r00*x847))+(((-1.0)*x848)));
evalcond[7]=((((-1.0)*x847*x848))+(((-1.0)*x850))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x853=((1.0)*sj6);
CheckValue<IkReal> x854 = IKatan2WithCheck(IkReal((((new_r01*sj6))+(((-1.0)*new_r10*x853)))),IkReal(((((-1.0)*new_r00*x853))+(((-1.0)*new_r11*x853)))),IKFAST_ATAN2_MAGTHRESH);
if(!x854.valid){
continue;
}
CheckValue<IkReal> x855=IKPowWithIntegerCheck(IKsign((((new_r10*new_r11))+((new_r00*new_r01)))),-1);
if(!x855.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x854.value)+(((1.5707963267949)*(x855.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x856=IKsin(j4);
IkReal x857=IKcos(j4);
IkReal x858=((1.0)*cj6);
IkReal x859=(sj6*x857);
IkReal x860=(sj6*x856);
IkReal x861=((1.0)*x856);
IkReal x862=(x856*x858);
evalcond[0]=(sj6+((new_r11*x856))+((new_r01*x857)));
evalcond[1]=(((cj6*x857))+new_r11+x860);
evalcond[2]=((((-1.0)*x862))+new_r01+x859);
evalcond[3]=(sj6+(((-1.0)*new_r00*x861))+((new_r10*x857)));
evalcond[4]=(cj6+(((-1.0)*new_r01*x861))+((new_r11*x857)));
evalcond[5]=((((-1.0)*x862))+new_r10+x859);
evalcond[6]=((((-1.0)*x858))+((new_r10*x856))+((new_r00*x857)));
evalcond[7]=((((-1.0)*x860))+new_r00+(((-1.0)*x857*x858)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x863 = IKatan2WithCheck(IkReal(((-1.0)+(new_r01*new_r01)+(cj6*cj6))),IkReal(((((-1.0)*new_r01*new_r11))+(((-1.0)*cj6*sj6)))),IKFAST_ATAN2_MAGTHRESH);
if(!x863.valid){
continue;
}
CheckValue<IkReal> x864=IKPowWithIntegerCheck(IKsign((((new_r11*sj6))+((cj6*new_r01)))),-1);
if(!x864.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(x863.value)+(((1.5707963267949)*(x864.value))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x865=IKsin(j4);
IkReal x866=IKcos(j4);
IkReal x867=((1.0)*cj6);
IkReal x868=(sj6*x866);
IkReal x869=(sj6*x865);
IkReal x870=((1.0)*x865);
IkReal x871=(x865*x867);
evalcond[0]=(((new_r01*x866))+sj6+((new_r11*x865)));
evalcond[1]=(((cj6*x866))+new_r11+x869);
evalcond[2]=(new_r01+x868+(((-1.0)*x871)));
evalcond[3]=(sj6+(((-1.0)*new_r00*x870))+((new_r10*x866)));
evalcond[4]=(cj6+(((-1.0)*new_r01*x870))+((new_r11*x866)));
evalcond[5]=(new_r10+x868+(((-1.0)*x871)));
evalcond[6]=((((-1.0)*x867))+((new_r00*x866))+((new_r10*x865)));
evalcond[7]=((((-1.0)*x866*x867))+(((-1.0)*x869))+new_r00);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r12))+(IKabs(new_r02)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs(new_r11))+(IKabs(new_r01)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs(new_r10))+(IKabs(new_r00)));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
new_r02=0;
new_r12=0;
new_r20=0;
new_r21=0;
j4eval[0]=((IKabs((new_r10*new_r22)))+(IKabs((new_r00*new_r22))));
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x873 = IKatan2WithCheck(IkReal((new_r10*new_r22)),IkReal(((-1.0)*new_r00*new_r22)),IKFAST_ATAN2_MAGTHRESH);
if(!x873.valid){
continue;
}
IkReal x872=x873.value;
j4array[0]=((-1.0)*x872);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x872)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x874=IKcos(j4);
IkReal x875=IKsin(j4);
IkReal x876=(new_r11*x874);
IkReal x877=((1.0)*x875);
evalcond[0]=(((new_r01*x874))+((new_r11*x875)));
evalcond[1]=(((new_r00*x874))+((new_r10*x875)));
evalcond[2]=((((-1.0)*new_r00*x877))+((new_r10*x874)));
evalcond[3]=((((-1.0)*new_r01*x877))+x876);
evalcond[4]=((((-1.0)*new_r01*new_r22*x877))+((new_r22*x876)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x879 = IKatan2WithCheck(IkReal(new_r00),IkReal(new_r10),IKFAST_ATAN2_MAGTHRESH);
if(!x879.valid){
continue;
}
IkReal x878=x879.value;
j4array[0]=((-1.0)*x878);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x878)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x880=IKcos(j4);
IkReal x881=IKsin(j4);
IkReal x882=(new_r10*x880);
IkReal x883=(new_r11*x880);
IkReal x884=((1.0)*new_r00*x881);
IkReal x885=((1.0)*new_r01*x881);
evalcond[0]=(((new_r01*x880))+((new_r11*x881)));
evalcond[1]=((((-1.0)*x884))+x882);
evalcond[2]=((((-1.0)*x885))+x883);
evalcond[3]=(((new_r22*x882))+(((-1.0)*new_r22*x884)));
evalcond[4]=(((new_r22*x883))+(((-1.0)*new_r22*x885)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[2], cj4array[2], sj4array[2];
bool j4valid[2]={false};
_nj4 = 2;
CheckValue<IkReal> x887 = IKatan2WithCheck(IkReal(new_r01),IkReal(new_r11),IKFAST_ATAN2_MAGTHRESH);
if(!x887.valid){
continue;
}
IkReal x886=x887.value;
j4array[0]=((-1.0)*x886);
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
j4array[1]=((3.14159265358979)+(((-1.0)*x886)));
sj4array[1]=IKsin(j4array[1]);
cj4array[1]=IKcos(j4array[1]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
if( j4array[1] > IKPI )
{
    j4array[1]-=IK2PI;
}
else if( j4array[1] < -IKPI )
{    j4array[1]+=IK2PI;
}
j4valid[1] = true;
for(int ij4 = 0; ij4 < 2; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 2; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[5];
IkReal x888=IKcos(j4);
IkReal x889=IKsin(j4);
IkReal x890=(new_r10*x888);
IkReal x891=(new_r11*x888);
IkReal x892=((1.0)*new_r00*x889);
IkReal x893=((1.0)*new_r01*x889);
evalcond[0]=(((new_r10*x889))+((new_r00*x888)));
evalcond[1]=((((-1.0)*x892))+x890);
evalcond[2]=((((-1.0)*x893))+x891);
evalcond[3]=(((new_r22*x890))+(((-1.0)*new_r22*x892)));
evalcond[4]=(((new_r22*x891))+(((-1.0)*new_r22*x893)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x895=IKPowWithIntegerCheck(sj5,-1);
if(!x895.valid){
continue;
}
IkReal x894=x895.value;
CheckValue<IkReal> x896=IKPowWithIntegerCheck(new_r01,-1);
if(!x896.valid){
continue;
}
if( IKabs(((-1.0)*new_r02*x894)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x894*(x896.value)*((((new_r02*new_r11))+(((-1.0)*sj5*sj6)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r02*x894))+IKsqr((x894*(x896.value)*((((new_r02*new_r11))+(((-1.0)*sj5*sj6))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((-1.0)*new_r02*x894), (x894*(x896.value)*((((new_r02*new_r11))+(((-1.0)*sj5*sj6))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x897=IKcos(j4);
IkReal x898=IKsin(j4);
IkReal x899=((1.0)*cj6);
IkReal x900=(cj5*sj6);
IkReal x901=((1.0)*cj5);
IkReal x902=(cj5*cj6);
IkReal x903=((1.0)*sj5);
IkReal x904=(new_r10*x897);
IkReal x905=(sj5*x898);
IkReal x906=((1.0)*x897);
IkReal x907=(new_r12*x897);
IkReal x908=(new_r01*x898);
IkReal x909=(new_r02*x898);
IkReal x910=(new_r00*x898);
IkReal x911=(new_r11*x897);
evalcond[0]=(new_r02+x905);
evalcond[1]=((((-1.0)*x897*x903))+new_r12);
evalcond[2]=(((new_r12*x898))+((new_r02*x897)));
evalcond[3]=(sj6+((new_r11*x898))+((new_r01*x897)));
evalcond[4]=(((sj6*x897))+new_r01+((x898*x902)));
evalcond[5]=(((new_r00*x897))+((new_r10*x898))+(((-1.0)*x899)));
evalcond[6]=((((-1.0)*x897*x899))+new_r00+((x898*x900)));
evalcond[7]=(((sj6*x898))+new_r11+(((-1.0)*cj5*x897*x899)));
evalcond[8]=((((-1.0)*x903))+(((-1.0)*x909))+x907);
evalcond[9]=((((-1.0)*x900*x906))+(((-1.0)*x898*x899))+new_r10);
evalcond[10]=((((-1.0)*x910))+(((-1.0)*x900))+x904);
evalcond[11]=((((-1.0)*x908))+(((-1.0)*cj5*x899))+x911);
evalcond[12]=(((cj5*x907))+(((-1.0)*x901*x909))+(((-1.0)*new_r22*x903)));
evalcond[13]=((((-1.0)*x903*x904))+(((-1.0)*new_r20*x901))+((new_r00*x905)));
evalcond[14]=((((-1.0)*new_r21*x901))+((new_r01*x905))+(((-1.0)*x903*x911)));
evalcond[15]=((1.0)+(((-1.0)*x903*x907))+((new_r02*x905))+(((-1.0)*new_r22*x901)));
evalcond[16]=((((-1.0)*sj6))+(((-1.0)*new_r20*x903))+((cj5*x904))+(((-1.0)*x901*x910)));
evalcond[17]=((((-1.0)*new_r21*x903))+(((-1.0)*x899))+(((-1.0)*x901*x908))+((cj5*x911)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x912=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x912.valid){
continue;
}
CheckValue<IkReal> x913 = IKatan2WithCheck(IkReal(((-1.0)*new_r02)),IkReal(new_r12),IKFAST_ATAN2_MAGTHRESH);
if(!x913.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x912.value)))+(x913.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[18];
IkReal x914=IKcos(j4);
IkReal x915=IKsin(j4);
IkReal x916=((1.0)*cj6);
IkReal x917=(cj5*sj6);
IkReal x918=((1.0)*cj5);
IkReal x919=(cj5*cj6);
IkReal x920=((1.0)*sj5);
IkReal x921=(new_r10*x914);
IkReal x922=(sj5*x915);
IkReal x923=((1.0)*x914);
IkReal x924=(new_r12*x914);
IkReal x925=(new_r01*x915);
IkReal x926=(new_r02*x915);
IkReal x927=(new_r00*x915);
IkReal x928=(new_r11*x914);
evalcond[0]=(new_r02+x922);
evalcond[1]=((((-1.0)*x914*x920))+new_r12);
evalcond[2]=(((new_r12*x915))+((new_r02*x914)));
evalcond[3]=(sj6+((new_r11*x915))+((new_r01*x914)));
evalcond[4]=(((sj6*x914))+((x915*x919))+new_r01);
evalcond[5]=((((-1.0)*x916))+((new_r10*x915))+((new_r00*x914)));
evalcond[6]=((((-1.0)*x914*x916))+((x915*x917))+new_r00);
evalcond[7]=((((-1.0)*cj5*x914*x916))+((sj6*x915))+new_r11);
evalcond[8]=((((-1.0)*x920))+(((-1.0)*x926))+x924);
evalcond[9]=(new_r10+(((-1.0)*x917*x923))+(((-1.0)*x915*x916)));
evalcond[10]=((((-1.0)*x927))+(((-1.0)*x917))+x921);
evalcond[11]=((((-1.0)*x925))+(((-1.0)*cj5*x916))+x928);
evalcond[12]=((((-1.0)*x918*x926))+(((-1.0)*new_r22*x920))+((cj5*x924)));
evalcond[13]=((((-1.0)*new_r20*x918))+(((-1.0)*x920*x921))+((new_r00*x922)));
evalcond[14]=((((-1.0)*new_r21*x918))+(((-1.0)*x920*x928))+((new_r01*x922)));
evalcond[15]=((1.0)+(((-1.0)*new_r22*x918))+((new_r02*x922))+(((-1.0)*x920*x924)));
evalcond[16]=((((-1.0)*sj6))+(((-1.0)*x918*x927))+(((-1.0)*new_r20*x920))+((cj5*x921)));
evalcond[17]=((((-1.0)*new_r21*x920))+(((-1.0)*x916))+(((-1.0)*x918*x925))+((cj5*x928)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[12]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[13]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[14]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[15]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[16]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[17]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x929=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x929.valid){
continue;
}
CheckValue<IkReal> x930 = IKatan2WithCheck(IkReal(((-1.0)*new_r02)),IkReal(new_r12),IKFAST_ATAN2_MAGTHRESH);
if(!x930.valid){
continue;
}
j4array[0]=((-1.5707963267949)+(((1.5707963267949)*(x929.value)))+(x930.value));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[8];
IkReal x931=IKcos(j4);
IkReal x932=IKsin(j4);
IkReal x933=((1.0)*sj5);
IkReal x934=((1.0)*cj5);
IkReal x935=(new_r02*x932);
IkReal x936=(new_r12*x931);
IkReal x937=(sj5*x932);
evalcond[0]=(new_r02+x937);
evalcond[1]=((((-1.0)*x931*x933))+new_r12);
evalcond[2]=(((new_r02*x931))+((new_r12*x932)));
evalcond[3]=((((-1.0)*x935))+x936+(((-1.0)*x933)));
evalcond[4]=((((-1.0)*x934*x935))+(((-1.0)*new_r22*x933))+((cj5*x936)));
evalcond[5]=(((new_r00*x937))+(((-1.0)*new_r10*x931*x933))+(((-1.0)*new_r20*x934)));
evalcond[6]=((((-1.0)*new_r21*x934))+(((-1.0)*new_r11*x931*x933))+((new_r01*x937)));
evalcond[7]=((1.0)+(((-1.0)*new_r22*x934))+(((-1.0)*x933*x936))+((sj5*x935)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=((IKabs(new_r20))+(IKabs(new_r21)));
j6eval[2]=IKsign(sj5);
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
j6eval[0]=cj4;
j6eval[1]=sj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal j6eval[3];
j6eval[0]=sj5;
j6eval[1]=cj5;
j6eval[2]=sj4;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal evalcond[5];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j5))), 6.28318530717959)));
evalcond[1]=new_r02;
evalcond[2]=new_r20;
evalcond[3]=new_r21;
evalcond[4]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x938=((1.0)*new_r01);
if( IKabs(((((-1.0)*cj4*x938))+(((-1.0)*new_r00*sj4)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj4*new_r00))+(((-1.0)*sj4*x938)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*x938))+(((-1.0)*new_r00*sj4))))+IKsqr((((cj4*new_r00))+(((-1.0)*sj4*x938))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*x938))+(((-1.0)*new_r00*sj4))), (((cj4*new_r00))+(((-1.0)*sj4*x938))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x939=IKcos(j6);
IkReal x940=IKsin(j6);
IkReal x941=((1.0)*sj4);
IkReal x942=(sj4*x940);
IkReal x943=((1.0)*x939);
IkReal x944=(sj4*x939);
IkReal x945=(cj4*x940);
IkReal x946=(cj4*x943);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x940);
evalcond[1]=((((-1.0)*x943))+((cj4*new_r00))+((new_r10*sj4)));
evalcond[2]=(new_r01+x944+x945);
evalcond[3]=((((-1.0)*x946))+new_r00+x942);
evalcond[4]=((((-1.0)*x946))+new_r11+x942);
evalcond[5]=(((cj4*new_r10))+(((-1.0)*x940))+(((-1.0)*new_r00*x941)));
evalcond[6]=((((-1.0)*x943))+((cj4*new_r11))+(((-1.0)*new_r01*x941)));
evalcond[7]=((((-1.0)*x939*x941))+(((-1.0)*x945))+new_r10);
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j5)))), 6.28318530717959)));
evalcond[1]=new_r02;
evalcond[2]=new_r20;
evalcond[3]=new_r21;
evalcond[4]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  && IKabs(evalcond[4]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
IkReal x947=((1.0)*new_r11);
if( IKabs(((((-1.0)*cj4*new_r01))+(((-1.0)*sj4*x947)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((new_r01*sj4))+(((-1.0)*cj4*x947)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj4*new_r01))+(((-1.0)*sj4*x947))))+IKsqr((((new_r01*sj4))+(((-1.0)*cj4*x947))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((((-1.0)*cj4*new_r01))+(((-1.0)*sj4*x947))), (((new_r01*sj4))+(((-1.0)*cj4*x947))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x948=IKsin(j6);
IkReal x949=IKcos(j6);
IkReal x950=((1.0)*sj4);
IkReal x951=(cj4*x948);
IkReal x952=((1.0)*x949);
IkReal x953=(x949*x950);
evalcond[0]=(((cj4*new_r01))+((new_r11*sj4))+x948);
evalcond[1]=(((cj4*new_r10))+(((-1.0)*new_r00*x950))+x948);
evalcond[2]=(((cj4*new_r11))+(((-1.0)*new_r01*x950))+x949);
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x952)));
evalcond[4]=(((sj4*x948))+new_r11+((cj4*x949)));
evalcond[5]=(new_r01+(((-1.0)*x953))+x951);
evalcond[6]=(new_r10+(((-1.0)*x953))+x951);
evalcond[7]=((((-1.0)*cj4*x952))+new_r00+(((-1.0)*x948*x950)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r20)) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20))+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r20), ((-1.0)*new_r21));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x954=IKsin(j6);
IkReal x955=IKcos(j6);
IkReal x956=((1.0)*x955);
evalcond[0]=(new_r20+x954);
evalcond[1]=(new_r21+x955);
evalcond[2]=(new_r01+((cj4*x954)));
evalcond[3]=(((sj4*x954))+new_r11);
evalcond[4]=(((new_r02*x955))+new_r10);
evalcond[5]=((((-1.0)*cj4*x956))+new_r00);
evalcond[6]=(((cj4*new_r01))+((new_r11*sj4))+x954);
evalcond[7]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x956)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r20, new_r21);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x957=IKsin(j6);
IkReal x958=IKcos(j6);
IkReal x959=((1.0)*x958);
evalcond[0]=((((-1.0)*x957))+new_r20);
evalcond[1]=(new_r21+(((-1.0)*x959)));
evalcond[2]=(new_r01+((cj4*x957)));
evalcond[3]=(((sj4*x957))+new_r11);
evalcond[4]=((((-1.0)*cj4*x959))+new_r00);
evalcond[5]=(new_r10+(((-1.0)*new_r02*x959)));
evalcond[6]=(((cj4*new_r01))+((new_r11*sj4))+x957);
evalcond[7]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x959)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j4))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r01)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r00) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r01))+IKsqr(new_r00)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r01), new_r00);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x960=IKsin(j6);
IkReal x961=IKcos(j6);
IkReal x962=((1.0)*sj5);
IkReal x963=((1.0)*x961);
IkReal x964=((1.0)*x960);
evalcond[0]=(new_r01+x960);
evalcond[1]=(new_r20+((new_r12*x960)));
evalcond[2]=(new_r21+((new_r12*x961)));
evalcond[3]=(new_r00+(((-1.0)*x963)));
evalcond[4]=((((-1.0)*cj5*x963))+new_r11);
evalcond[5]=((((-1.0)*cj5*x964))+new_r10);
evalcond[6]=(((cj5*new_r10))+(((-1.0)*new_r20*x962))+(((-1.0)*x964)));
evalcond[7]=((((-1.0)*new_r21*x962))+((cj5*new_r11))+(((-1.0)*x963)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j4)))), 6.28318530717959)));
evalcond[1]=new_r02;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r01) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r00)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r01)+IKsqr(((-1.0)*new_r00))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r01, ((-1.0)*new_r00));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x965=IKsin(j6);
IkReal x966=IKcos(j6);
CheckValue<IkReal> x972=IKPowWithIntegerCheck(new_r12,-1);
if(!x972.valid){
continue;
}
IkReal x967=x972.value;
IkReal x968=new_r22*new_r22;
IkReal x969=((1.0)*x966);
IkReal x970=(x967*x968);
IkReal x971=((1.0)*x965);
evalcond[0]=((((-1.0)*new_r01))+x965);
evalcond[1]=(new_r11+((cj5*x966)));
evalcond[2]=((((-1.0)*new_r12*x971))+new_r20);
evalcond[3]=((((-1.0)*new_r12*x969))+new_r21);
evalcond[4]=((((-1.0)*new_r00))+(((-1.0)*x969)));
evalcond[5]=((((-1.0)*new_r10))+(((-1.0)*cj5*x971)));
evalcond[6]=(((new_r20*x970))+((new_r12*new_r20))+(((-1.0)*x971)));
evalcond[7]=(((new_r12*new_r21))+((new_r21*x970))+(((-1.0)*x969)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(((-1.0)*new_r11)) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r10) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r11))+IKsqr(new_r10)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r11), new_r10);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x973=IKcos(j6);
IkReal x974=IKsin(j6);
CheckValue<IkReal> x980=IKPowWithIntegerCheck(new_r02,-1);
if(!x980.valid){
continue;
}
IkReal x975=x980.value;
IkReal x976=new_r22*new_r22;
IkReal x977=((1.0)*x973);
IkReal x978=(x975*x976);
IkReal x979=((1.0)*x974);
evalcond[0]=(new_r11+x974);
evalcond[1]=(new_r10+(((-1.0)*x977)));
evalcond[2]=(((cj5*x973))+new_r01);
evalcond[3]=(((cj5*x974))+new_r00);
evalcond[4]=((((-1.0)*new_r02*x979))+new_r20);
evalcond[5]=((((-1.0)*new_r02*x977))+new_r21);
evalcond[6]=(((new_r20*x978))+((new_r02*new_r20))+(((-1.0)*x979)));
evalcond[7]=(((new_r21*x978))+((new_r02*new_r21))+(((-1.0)*x977)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j4)))), 6.28318530717959)));
evalcond[1]=new_r12;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[3];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
j6eval[0]=new_r02;
j6eval[1]=IKsign(new_r02);
j6eval[2]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  || IKabs(j6eval[2]) < 0.0000010000000000  )
{
{
IkReal j6eval[1];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
j6eval[0]=new_r02;
if( IKabs(j6eval[0]) < 0.0000010000000000  )
{
{
IkReal j6eval[2];
sj4=-1.0;
cj4=0;
j4=-1.5707963267949;
j6eval[0]=new_r02;
j6eval[1]=cj5;
if( IKabs(j6eval[0]) < 0.0000010000000000  || IKabs(j6eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[4];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r21))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r11, ((-1.0)*new_r21));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x981=IKsin(j6);
IkReal x982=IKcos(j6);
evalcond[0]=(new_r20+x981);
evalcond[1]=(new_r21+x982);
evalcond[2]=((((-1.0)*new_r11))+x981);
evalcond[3]=((((-1.0)*x982))+(((-1.0)*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j5)))), 6.28318530717959)));
evalcond[1]=new_r22;
evalcond[2]=new_r01;
evalcond[3]=new_r00;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  && IKabs(evalcond[3]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r20) < IKFAST_ATAN2_MAGTHRESH && IKabs(new_r21) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r20)+IKsqr(new_r21)-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r20, new_r21);
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[4];
IkReal x983=IKsin(j6);
IkReal x984=((1.0)*(IKcos(j6)));
evalcond[0]=((((-1.0)*x983))+new_r20);
evalcond[1]=((((-1.0)*x984))+new_r21);
evalcond[2]=((((-1.0)*new_r11))+x983);
evalcond[3]=((((-1.0)*x984))+(((-1.0)*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=IKabs(new_r02);
evalcond[1]=new_r20;
evalcond[2]=new_r21;
if( IKabs(evalcond[0]) < 0.0000050000000000  && IKabs(evalcond[1]) < 0.0000050000000000  && IKabs(evalcond[2]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x985=IKsin(j6);
IkReal x986=IKcos(j6);
IkReal x987=((1.0)*x986);
IkReal x988=((1.0)*x985);
evalcond[0]=((((-1.0)*new_r11))+x985);
evalcond[1]=(new_r01+(((-1.0)*cj5*x987)));
evalcond[2]=(new_r00+(((-1.0)*cj5*x988)));
evalcond[3]=((((-1.0)*x987))+(((-1.0)*new_r10)));
evalcond[4]=((((-1.0)*x988))+((cj5*new_r00)));
evalcond[5]=((((-1.0)*x987))+((cj5*new_r01)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r10)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r10))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r11, ((-1.0)*new_r10));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[6];
IkReal x989=IKcos(j6);
IkReal x990=IKsin(j6);
IkReal x991=((-1.0)*x989);
IkReal x992=((-1.0)*x990);
evalcond[0]=x992;
evalcond[1]=x991;
evalcond[2]=(new_r22*x991);
evalcond[3]=(new_r22*x992);
evalcond[4]=((((-1.0)*new_r11))+x990);
evalcond[5]=((((-1.0)*x989))+(((-1.0)*new_r10)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x993=IKPowWithIntegerCheck(new_r02,-1);
if(!x993.valid){
continue;
}
CheckValue<IkReal> x994=IKPowWithIntegerCheck(cj5,-1);
if(!x994.valid){
continue;
}
if( IKabs(((-1.0)*new_r20*(x993.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs((new_r01*(x994.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20*(x993.value)))+IKsqr((new_r01*(x994.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r20*(x993.value)), (new_r01*(x994.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x995=IKsin(j6);
IkReal x996=IKcos(j6);
IkReal x997=((1.0)*sj5);
IkReal x998=((1.0)*x996);
IkReal x999=((1.0)*x995);
evalcond[0]=(((new_r02*x995))+new_r20);
evalcond[1]=(((new_r02*x996))+new_r21);
evalcond[2]=((((-1.0)*new_r11))+x995);
evalcond[3]=((((-1.0)*cj5*x998))+new_r01);
evalcond[4]=((((-1.0)*cj5*x999))+new_r00);
evalcond[5]=((((-1.0)*x998))+(((-1.0)*new_r10)));
evalcond[6]=(((cj5*new_r00))+(((-1.0)*x999))+(((-1.0)*new_r20*x997)));
evalcond[7]=(((cj5*new_r01))+(((-1.0)*x998))+(((-1.0)*new_r21*x997)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1000=IKPowWithIntegerCheck(new_r02,-1);
if(!x1000.valid){
continue;
}
if( IKabs(new_r11) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21*(x1000.value))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(new_r11)+IKsqr(((-1.0)*new_r21*(x1000.value)))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(new_r11, ((-1.0)*new_r21*(x1000.value)));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x1001=IKsin(j6);
IkReal x1002=IKcos(j6);
IkReal x1003=((1.0)*sj5);
IkReal x1004=((1.0)*x1002);
IkReal x1005=((1.0)*x1001);
evalcond[0]=(new_r20+((new_r02*x1001)));
evalcond[1]=(new_r21+((new_r02*x1002)));
evalcond[2]=(x1001+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*cj5*x1004))+new_r01);
evalcond[4]=((((-1.0)*cj5*x1005))+new_r00);
evalcond[5]=((((-1.0)*x1004))+(((-1.0)*new_r10)));
evalcond[6]=((((-1.0)*x1005))+((cj5*new_r00))+(((-1.0)*new_r20*x1003)));
evalcond[7]=((((-1.0)*x1004))+((cj5*new_r01))+(((-1.0)*new_r21*x1003)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1006=IKPowWithIntegerCheck(IKsign(new_r02),-1);
if(!x1006.valid){
continue;
}
CheckValue<IkReal> x1007 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),IkReal(((-1.0)*new_r21)),IKFAST_ATAN2_MAGTHRESH);
if(!x1007.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1006.value)))+(x1007.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[8];
IkReal x1008=IKsin(j6);
IkReal x1009=IKcos(j6);
IkReal x1010=((1.0)*sj5);
IkReal x1011=((1.0)*x1009);
IkReal x1012=((1.0)*x1008);
evalcond[0]=(new_r20+((new_r02*x1008)));
evalcond[1]=(new_r21+((new_r02*x1009)));
evalcond[2]=(x1008+(((-1.0)*new_r11)));
evalcond[3]=((((-1.0)*cj5*x1011))+new_r01);
evalcond[4]=((((-1.0)*cj5*x1012))+new_r00);
evalcond[5]=((((-1.0)*x1011))+(((-1.0)*new_r10)));
evalcond[6]=((((-1.0)*x1012))+((cj5*new_r00))+(((-1.0)*new_r20*x1010)));
evalcond[7]=((((-1.0)*x1011))+((cj5*new_r01))+(((-1.0)*new_r21*x1010)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((IKabs(new_r20))+(IKabs(new_r21)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j6eval[1];
new_r21=0;
new_r20=0;
new_r02=0;
new_r12=0;
j6eval[0]=1.0;
if( IKabs(j6eval[0]) < 0.0000000100000000  )
{
continue; // no branches [j6]

} else
{
IkReal op[2+1], zeror[2];
int numroots;
op[0]=-1.0;
op[1]=0;
op[2]=1.0;
polyroots2(op,zeror,numroots);
IkReal j6array[2], cj6array[2], sj6array[2], tempj6array[1];
int numsolutions = 0;
for(int ij6 = 0; ij6 < numroots; ++ij6)
{
IkReal htj6 = zeror[ij6];
tempj6array[0]=((2.0)*(atan(htj6)));
for(int kj6 = 0; kj6 < 1; ++kj6)
{
j6array[numsolutions] = tempj6array[kj6];
if( j6array[numsolutions] > IKPI )
{
    j6array[numsolutions]-=IK2PI;
}
else if( j6array[numsolutions] < -IKPI )
{
    j6array[numsolutions]+=IK2PI;
}
sj6array[numsolutions] = IKsin(j6array[numsolutions]);
cj6array[numsolutions] = IKcos(j6array[numsolutions]);
numsolutions++;
}
}
bool j6valid[2]={true,true};
_nj6 = 2;
for(int ij6 = 0; ij6 < numsolutions; ++ij6)
    {
if( !j6valid[ij6] )
{
    continue;
}
    j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
htj6 = IKtan(j6/2);

_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < numsolutions; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
    }

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j6]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1014=IKPowWithIntegerCheck(sj5,-1);
if(!x1014.valid){
continue;
}
IkReal x1013=x1014.value;
CheckValue<IkReal> x1015=IKPowWithIntegerCheck(cj5,-1);
if(!x1015.valid){
continue;
}
CheckValue<IkReal> x1016=IKPowWithIntegerCheck(sj4,-1);
if(!x1016.valid){
continue;
}
if( IKabs(((-1.0)*new_r20*x1013)) < IKFAST_ATAN2_MAGTHRESH && IKabs((x1013*(x1015.value)*(x1016.value)*(((((-1.0)*new_r01*sj5))+((cj4*new_r20)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-1.0)*new_r20*x1013))+IKsqr((x1013*(x1015.value)*(x1016.value)*(((((-1.0)*new_r01*sj5))+((cj4*new_r20))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2(((-1.0)*new_r20*x1013), (x1013*(x1015.value)*(x1016.value)*(((((-1.0)*new_r01*sj5))+((cj4*new_r20))))));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x1017=IKsin(j6);
IkReal x1018=IKcos(j6);
IkReal x1019=((1.0)*sj4);
IkReal x1020=(cj4*cj5);
IkReal x1021=((1.0)*sj5);
IkReal x1022=((1.0)*x1018);
IkReal x1023=((1.0)*x1017);
IkReal x1024=(sj4*x1017);
evalcond[0]=(((sj5*x1017))+new_r20);
evalcond[1]=(((sj5*x1018))+new_r21);
evalcond[2]=(x1017+((cj4*new_r01))+((new_r11*sj4)));
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x1022)));
evalcond[4]=(((cj5*sj4*x1018))+((cj4*x1017))+new_r01);
evalcond[5]=((((-1.0)*cj4*x1022))+((cj5*x1024))+new_r00);
evalcond[6]=(x1024+(((-1.0)*x1020*x1022))+new_r11);
evalcond[7]=((((-1.0)*cj5*x1023))+((cj4*new_r10))+(((-1.0)*new_r00*x1019)));
evalcond[8]=((((-1.0)*cj5*x1022))+((cj4*new_r11))+(((-1.0)*new_r01*x1019)));
evalcond[9]=((((-1.0)*x1018*x1019))+(((-1.0)*x1020*x1023))+new_r10);
evalcond[10]=(((new_r10*x1020))+(((-1.0)*cj5*new_r00*x1019))+(((-1.0)*x1023))+(((-1.0)*new_r20*x1021)));
evalcond[11]=(((new_r11*x1020))+(((-1.0)*x1022))+(((-1.0)*new_r21*x1021))+(((-1.0)*cj5*new_r01*x1019)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1026=IKPowWithIntegerCheck(sj5,-1);
if(!x1026.valid){
continue;
}
IkReal x1025=x1026.value;
CheckValue<IkReal> x1027=IKPowWithIntegerCheck(cj4,-1);
if(!x1027.valid){
continue;
}
if( IKabs((x1025*(x1027.value)*(((((-1.0)*new_r01*sj5))+((cj5*new_r21*sj4)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-1.0)*new_r21*x1025)) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x1025*(x1027.value)*(((((-1.0)*new_r01*sj5))+((cj5*new_r21*sj4))))))+IKsqr(((-1.0)*new_r21*x1025))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j6array[0]=IKatan2((x1025*(x1027.value)*(((((-1.0)*new_r01*sj5))+((cj5*new_r21*sj4))))), ((-1.0)*new_r21*x1025));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x1028=IKsin(j6);
IkReal x1029=IKcos(j6);
IkReal x1030=((1.0)*sj4);
IkReal x1031=(cj4*cj5);
IkReal x1032=((1.0)*sj5);
IkReal x1033=((1.0)*x1029);
IkReal x1034=((1.0)*x1028);
IkReal x1035=(sj4*x1028);
evalcond[0]=(new_r20+((sj5*x1028)));
evalcond[1]=(new_r21+((sj5*x1029)));
evalcond[2]=(x1028+((cj4*new_r01))+((new_r11*sj4)));
evalcond[3]=((((-1.0)*x1033))+((cj4*new_r00))+((new_r10*sj4)));
evalcond[4]=(((cj4*x1028))+((cj5*sj4*x1029))+new_r01);
evalcond[5]=((((-1.0)*cj4*x1033))+((cj5*x1035))+new_r00);
evalcond[6]=(x1035+(((-1.0)*x1031*x1033))+new_r11);
evalcond[7]=((((-1.0)*cj5*x1034))+((cj4*new_r10))+(((-1.0)*new_r00*x1030)));
evalcond[8]=((((-1.0)*cj5*x1033))+((cj4*new_r11))+(((-1.0)*new_r01*x1030)));
evalcond[9]=((((-1.0)*x1029*x1030))+(((-1.0)*x1031*x1034))+new_r10);
evalcond[10]=((((-1.0)*cj5*new_r00*x1030))+(((-1.0)*x1034))+((new_r10*x1031))+(((-1.0)*new_r20*x1032)));
evalcond[11]=((((-1.0)*x1033))+(((-1.0)*cj5*new_r01*x1030))+((new_r11*x1031))+(((-1.0)*new_r21*x1032)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j6array[1], cj6array[1], sj6array[1];
bool j6valid[1]={false};
_nj6 = 1;
CheckValue<IkReal> x1036=IKPowWithIntegerCheck(IKsign(sj5),-1);
if(!x1036.valid){
continue;
}
CheckValue<IkReal> x1037 = IKatan2WithCheck(IkReal(((-1.0)*new_r20)),IkReal(((-1.0)*new_r21)),IKFAST_ATAN2_MAGTHRESH);
if(!x1037.valid){
continue;
}
j6array[0]=((-1.5707963267949)+(((1.5707963267949)*(x1036.value)))+(x1037.value));
sj6array[0]=IKsin(j6array[0]);
cj6array[0]=IKcos(j6array[0]);
if( j6array[0] > IKPI )
{
    j6array[0]-=IK2PI;
}
else if( j6array[0] < -IKPI )
{    j6array[0]+=IK2PI;
}
j6valid[0] = true;
for(int ij6 = 0; ij6 < 1; ++ij6)
{
if( !j6valid[ij6] )
{
    continue;
}
_ij6[0] = ij6; _ij6[1] = -1;
for(int iij6 = ij6+1; iij6 < 1; ++iij6)
{
if( j6valid[iij6] && IKabs(cj6array[ij6]-cj6array[iij6]) < IKFAST_SOLUTION_THRESH && IKabs(sj6array[ij6]-sj6array[iij6]) < IKFAST_SOLUTION_THRESH )
{
    j6valid[iij6]=false; _ij6[1] = iij6; break; 
}
}
j6 = j6array[ij6]; cj6 = cj6array[ij6]; sj6 = sj6array[ij6];
{
IkReal evalcond[12];
IkReal x1038=IKsin(j6);
IkReal x1039=IKcos(j6);
IkReal x1040=((1.0)*sj4);
IkReal x1041=(cj4*cj5);
IkReal x1042=((1.0)*sj5);
IkReal x1043=((1.0)*x1039);
IkReal x1044=((1.0)*x1038);
IkReal x1045=(sj4*x1038);
evalcond[0]=(((sj5*x1038))+new_r20);
evalcond[1]=(((sj5*x1039))+new_r21);
evalcond[2]=(x1038+((cj4*new_r01))+((new_r11*sj4)));
evalcond[3]=(((cj4*new_r00))+((new_r10*sj4))+(((-1.0)*x1043)));
evalcond[4]=(((cj5*sj4*x1039))+((cj4*x1038))+new_r01);
evalcond[5]=((((-1.0)*cj4*x1043))+new_r00+((cj5*x1045)));
evalcond[6]=(x1045+(((-1.0)*x1041*x1043))+new_r11);
evalcond[7]=(((cj4*new_r10))+(((-1.0)*new_r00*x1040))+(((-1.0)*cj5*x1044)));
evalcond[8]=(((cj4*new_r11))+(((-1.0)*new_r01*x1040))+(((-1.0)*cj5*x1043)));
evalcond[9]=((((-1.0)*x1039*x1040))+(((-1.0)*x1041*x1044))+new_r10);
evalcond[10]=((((-1.0)*new_r20*x1042))+(((-1.0)*cj5*new_r00*x1040))+((new_r10*x1041))+(((-1.0)*x1044)));
evalcond[11]=((((-1.0)*new_r21*x1042))+((new_r11*x1041))+(((-1.0)*cj5*new_r01*x1040))+(((-1.0)*x1043)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[3]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[4]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[5]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[6]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[7]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[8]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[9]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[10]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[11]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(7);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
vinfos[5].jointtype = 1;
vinfos[5].foffset = j5;
vinfos[5].indices[0] = _ij5[0];
vinfos[5].indices[1] = _ij5[1];
vinfos[5].maxsolutions = _nj5;
vinfos[6].jointtype = 1;
vinfos[6].foffset = j6;
vinfos[6].indices[0] = _ij6[0];
vinfos[6].indices[1] = _ij6[1];
vinfos[6].maxsolutions = _nj6;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
}
}static inline void polyroots3(IkReal rawcoeffs[3+1], IkReal rawroots[3], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots2(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[3];
    const int maxsteps = 110;
    for(int i = 0; i < 3; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[3];
    IkReal err[3];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 3; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 3; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 3; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 3; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[3] = {false};
    for(int i = 0; i < 3; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 3; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots2(IkReal rawcoeffs[2+1], IkReal rawroots[2], int& numroots) {
    IkReal det = rawcoeffs[1]*rawcoeffs[1]-4*rawcoeffs[0]*rawcoeffs[2];
    if( det < 0 ) {
        numroots=0;
    }
    else if( det == 0 ) {
        rawroots[0] = -0.5*rawcoeffs[1]/rawcoeffs[0];
        numroots = 1;
    }
    else {
        det = IKsqrt(det);
        rawroots[0] = (-rawcoeffs[1]+det)/(2*rawcoeffs[0]);
        rawroots[1] = (-rawcoeffs[1]-det)/(2*rawcoeffs[0]);//rawcoeffs[2]/(rawcoeffs[0]*rawroots[0]);
        numroots = 2;
    }
}
static inline void polyroots5(IkReal rawcoeffs[5+1], IkReal rawroots[5], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots4(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[5];
    const int maxsteps = 110;
    for(int i = 0; i < 5; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[5];
    IkReal err[5];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 5; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 5; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 5; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 5; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[5] = {false};
    for(int i = 0; i < 5; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 5; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots4(IkReal rawcoeffs[4+1], IkReal rawroots[4], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots3(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[4];
    const int maxsteps = 110;
    for(int i = 0; i < 4; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[4];
    IkReal err[4];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 4; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 4; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 4; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 4; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[4] = {false};
    for(int i = 0; i < 4; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 4; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots7(IkReal rawcoeffs[7+1], IkReal rawroots[7], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots6(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[7];
    const int maxsteps = 110;
    for(int i = 0; i < 7; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[7];
    IkReal err[7];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 7; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 7; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 7; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 7; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[7] = {false};
    for(int i = 0; i < 7; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 7; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots6(IkReal rawcoeffs[6+1], IkReal rawroots[6], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots5(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[6];
    const int maxsteps = 110;
    for(int i = 0; i < 6; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[6];
    IkReal err[6];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 6; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 6; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 6; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 6; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[6] = {false};
    for(int i = 0; i < 6; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 6; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
static inline void polyroots8(IkReal rawcoeffs[8+1], IkReal rawroots[8], int& numroots)
{
    using std::complex;
    if( rawcoeffs[0] == 0 ) {
        // solve with one reduced degree
        polyroots7(&rawcoeffs[1], &rawroots[0], numroots);
        return;
    }
    IKFAST_ASSERT(rawcoeffs[0] != 0);
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    const IkReal tolsqrt = sqrt(std::numeric_limits<IkReal>::epsilon());
    complex<IkReal> coeffs[8];
    const int maxsteps = 110;
    for(int i = 0; i < 8; ++i) {
        coeffs[i] = complex<IkReal>(rawcoeffs[i+1]/rawcoeffs[0]);
    }
    complex<IkReal> roots[8];
    IkReal err[8];
    roots[0] = complex<IkReal>(1,0);
    roots[1] = complex<IkReal>(0.4,0.9); // any complex number not a root of unity works
    err[0] = 1.0;
    err[1] = 1.0;
    for(int i = 2; i < 8; ++i) {
        roots[i] = roots[i-1]*roots[1];
        err[i] = 1.0;
    }
    for(int step = 0; step < maxsteps; ++step) {
        bool changed = false;
        for(int i = 0; i < 8; ++i) {
            if ( err[i] >= tol ) {
                changed = true;
                // evaluate
                complex<IkReal> x = roots[i] + coeffs[0];
                for(int j = 1; j < 8; ++j) {
                    x = roots[i] * x + coeffs[j];
                }
                for(int j = 0; j < 8; ++j) {
                    if( i != j ) {
                        if( roots[i] != roots[j] ) {
                            x /= (roots[i] - roots[j]);
                        }
                    }
                }
                roots[i] -= x;
                err[i] = abs(x);
            }
        }
        if( !changed ) {
            break;
        }
    }

    numroots = 0;
    bool visited[8] = {false};
    for(int i = 0; i < 8; ++i) {
        if( !visited[i] ) {
            // might be a multiple root, in which case it will have more error than the other roots
            // find any neighboring roots, and take the average
            complex<IkReal> newroot=roots[i];
            int n = 1;
            for(int j = i+1; j < 8; ++j) {
                // care about error in real much more than imaginary
                if( abs(real(roots[i])-real(roots[j])) < tolsqrt && abs(imag(roots[i])-imag(roots[j])) < 0.002 ) {
                    newroot += roots[j];
                    n += 1;
                    visited[j] = true;
                }
            }
            if( n > 1 ) {
                newroot /= n;
            }
            // there are still cases where even the mean is not accurate enough, until a better multi-root algorithm is used, need to use the sqrt
            if( IKabs(imag(newroot)) < tolsqrt ) {
                rawroots[numroots++] = real(newroot);
            }
        }
    }
}
};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "289bf88931819ec2e05e7eb19f4a0afe"; }

IKFAST_API const char* GetIkFastVersion() { return "0x10000049"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
